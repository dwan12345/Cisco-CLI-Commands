var MAP_MAX_METER = 3000.0;
var MAP_MIN_METER = 3.0;
var MAP_MAX_FEET = 9840.0;
var MAP_MIN_FEET = 9.84;
var METER_FEET_SCALE = 3.28;// 1米约等于3.28英尺

var LINEWIDTH_ZONE_STROKE = 2;// 区域矩形框线宽
var LINEWIDTH_ZONE_IN = 0.2;// 区域内部斜线线宽
var OBFIELD_COVERAGE = "zone";// 信号覆盖区
var OBFIELD_EXCLUSION = "nonap";// 无ＡＰ区域

var OBFIELD_ELEVATOR = "elevator";

var LINEWIDTH_AREA_STROKE = 1;// 区域矩形框线宽
var LINEWIDTH_AREA_IN = 0.5;// 区域内部斜线线宽

var LINEWIDTH_OBSTACLE_STROKE = 1;

var COLOR_SEL = "#f13b3d";// 选择框线条颜色
var LINEWIDTH_SEL = 2;// 选择框线条宽度
var SHADOW_COLOR = "rgba(0,0,0,0.7)";
var SHADOW_BLUR = 10;
var SIDELENGTH_AP = 50;// AP图片的边长
var SIDELENGTH_ANTENNA = 28;// 天线图片边长

var TYPE_RECT_ZONE = "zone";// 当前画图对象为zone
var TYPE_RECT_WALL = "obstacle";// 当前画图对象为障碍物
var TYPE_RECT_AREA = "area";// 当前画图对象为area
var TYPE_DRAW_Rule = "rule";// 当前画图对象为更改比例尺
var TYPE_DRAW_Ruler = "ruler";// 测量工具

var LABEL_COLOR = "#e97920";// 文本颜色
var LABEL_COLOR_AP = "#000";
var GRID_LINE_COLOR = '#5b686d';// 网格线条颜色
var GRID_SENCOND_LINE_COLOR = '#778f9b';
var AP_LINE_ANTENNA_COLOR = "#555555";// AP与天线之间的连线颜色

var MINISTEP = 2;// 自动调整幅度
var WIDTH_GUIDE = 1;// 辅助线宽度
var COLOR_GUIDE = "#e97920";// 辅助线颜色
var COLOR_RULE = "#ef6191";
var COLOR_RULER = "#ec407a";
var COLOR_RULER_FILL = "#fce4ec";
var WIDTH_RULE = 2;
var CURSOR_ROTATE = "url('./resource/cursors/rotate.cur'), auto";
var CURSOR_HAND = "url('./resource/cursors/hand.cur'), auto";
var CURSOR_CATCH = "url('./resource/cursors/catch.cur'), auto";
var CURSOR_POINTER = "url('./resource/cursors/pointer.cur'), auto";
var CURSOR_ADDAP = "url('./resource/cursors/add_ap.cur') 26 26, auto";

var COLORArray = [ '#fc0000', '#fc0000', '#fc0000', '#fc0000', '#fc0000',
		'#fc0000', '#fc0000', '#fc0000', '#fc0000', '#fc0000', '#fc0000',
		'#ff1e05', '#ff330a', '#ff450d', '#ff570f', '#ff6d12', '#ff7c17',
		'#ff9019', '#ff9f19', '#ffb01f', '#ffbf1f', '#fac423', '#f0c424',
		'#e6c327', '#d9c52b', '#ccc72f', '#bbc734', '#a8c738', '#92c73e',
		'#7dc744', '#63c94f', '#4bc951', '#4cc756', '#4cc75c', '#4ec766',
		'#4fc46e', '#52c47c', '#53c287', '#56bf97', '#57bda5', '#5bbdb9',
		'#5dbbc9', '#5fbad9', '#65b8f0', '#72bbf7', '#82c3f5', '#99cff7',
		'#b1dafa', '#cae5fa', '#e3f2fc' ];
var COLORArrayOpp = [ '#e3f2fc', '#e3f2fc', '#e3f2fc', '#e3f2fc', '#e3f2fc',
		'#cae5fa', '#cae5fa', '#cae5fa', '#cae5fa', '#b1dafa', '#b1dafa',
		'#b1dafa', '#99cff7', '#99cff7', '#82c3f5', '#72bbf7', '#65b8f0',
		'#5fbad9', '#5dbbc9', '#5bbdb9', '#57bda5', '#56bf97', '#53c287',
		'#52c47c', '#4fc46e', '#4ec766', '#4cc75c', '#4cc756', '#4bc951',
		'#63c94f', '#7dc744', '#92c73e', '#a8c738', '#bbc734', '#ccc72f',
		'#d9c52b', '#e6c327', '#f0c424', '#fac423', '#ffbf1f', '#ffb01f',
		'#ff9f19', '#ff9019', '#ff7c17', '#ff6d12', '#ff570f', '#ff450d',
		'#ff330a', '#ff1e05', '#fc0000' ];

var COLORArray1 = [ '#ff0000', '#ff1f00', '#ff3500', '#ff5000', '#ff6a00',
		'#ff8400', '#ff9f00', '#ffbd00', '#ffd600', '#fff000', '#f3ff00',
		'#d6ff00', '#bdff00', '#a2ff00', '#87ff00', '#6dff00', '#53ff00',
		'#38ff00', '#1dff00', '#02ff00', '#06fd17', '#0dfc30', '#13fa48',
		'#1af862', '#21f67c', '#27f592', '#2ef3ab', '#35f1c6', '#3cefdd',
		'#47efef', '#5af0f0', '#6ef2f2', '#84f4f4', '#97f6f6', '#aaf8f8',
		'#bef9f9', '#d3fbfb', '#e5fdfd', '#ffffff', '#ffffff' ];

var ImagePainter = function(imageUrl, px, py, pw, ph) {
	this.image = new Image;
	this.image.crossOrigin = "Anonymous";
	this.src = imageUrl;
	this.imageloaded = false;
	this.image.src = imageUrl + "?" + Math.random();
	// this.image.src = imageUrl;
	this.px = px;
	this.py = py;
	this.pw = pw;
	this.ph = ph;
};

ImagePainter.prototype = {
	image : undefined,

	paint : function(context, callback) {
		if (this.image !== undefined) {
			if (!this.image.complete) {
				var self = this;
				this.image.onload = function(e) {
					if (context)
						context.drawImage(this, self.px, self.py, self.pw,
								self.ph);

					self.imageloaded = true;
					if (callback != null)
						callback();
				};
				this.image.onerror = function(e) {
					self.imageloaded = false;
				};

			} else {
				if (this.imageloaded) {
					if (context)
						context.drawImage(this.image, this.px, this.py,
								this.pw, this.ph);

					if (callback != null)
						callback();
				} else {
					this.image.src = this.src + "?" + Math.random();
				}
			}
		}
	}
};

/*
 * 画实线
 */
function drawLine(x1, y1, x2, y2, context) {

	context.beginPath();
	context.moveTo(x1, y1);
	context.lineTo(x2, y2);
	context.closePath();
	context.stroke();
};

/*
 * 画虚线
 */

function drawDashedLine_old(x1, y1, x2, y2, context, dashLength) {
	dashLength = dashLength === undefined ? 5 : dashLength;
	context.beginPath();
	var deltaX = x2 - x1;
	var deltaY = y2 - y1;
	var numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY)
			/ dashLength);

	for (var i = 0; i < numDashes; ++i) {
		context[i % 2 === 0 ? 'moveTo' : 'lineTo'](x1 + (deltaX / numDashes)
				* i, y1 + (deltaY / numDashes) * i);
	}
	context.closePath();
	context.stroke();
};

function drawDashedLine(x1, y1, x2, y2, context, dashLength1, dashLength2) {
	dashLength1 = dashLength1 === undefined ? 2 : dashLength1;
	dashLength2 = dashLength2 === undefined ? 6 : dashLength2;
	context.beginPath();
	var deltaX = x2 - x1;
	var deltaY = y2 - y1;
	var numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY)
			/ ((dashLength1 + dashLength2) / 2));

	var span = (dashLength2 - dashLength1) / (dashLength1 + dashLength2);

	for (var i = 0; i < numDashes; ++i) {
		if (i % 2 === 0)
			context['moveTo'](x1 + (deltaX / numDashes) * i, y1
					+ (deltaY / numDashes) * i);
		else
			context['lineTo'](x1 + (deltaX / numDashes) * (i + span), y1
					+ (deltaY / numDashes) * (i + span));
	}
	context.closePath();
	context.stroke();
};

Array.prototype.indexOf = function(val) {
	for (var i = 0; i < this.length; i++) {
		if (this[i] == val)
			return i;
	}
	return -1;
};

Array.prototype.contains = function(item) {
	var index = this.indexOf(item);
	return (index >= 0);
};

Array.prototype.remove = function(val) {
	var index = this.indexOf(val);
	if (index > -1) {
		this.splice(index, 1);
	}
};

/**
 * 获取各种对象的颜色，
 * 
 * @param type
 * @returns
 */
function getRectColor(type, p) {

	if (obStyleArray[type]) {
		if (p == 1) {
			return obStyleArray[type].color;
		} else {
			return obStyleArray[type].border;
		}
	}

	return "#000";
}

var tempHash = function() {
	this.options = {};
};

tempHash.prototype = {
	push : function(n, v) {
		if (n == undefined)
			return v;
		var A = n.split("."), L = A.length - 1, V = this.options;
		for (var i = 0; i < L; i++) {
			if (!V[A[i]])
				V[A[i]] = {};
			V = V[A[i]];
		}
		V[A[L]] = v;
		return v;
	},
	get : function(n) {
		if (n == undefined)
			return null;
		var A = n.split("."), V = this.options[A[0]];
		for (var i = 1; i < A.length; i++) {
			if (!V)
				return null;
			V = V[A[i]];
		}
		return V;
	},
	clearData : function() {
		this.options = {};
	},
	length : function() {
		var V = this.options;
		var count = 0;
		for ( var key in V) {
			count++;
		}
		return count;
	}
};

var sharpness = 0.5;
var heatImages = new tempHash();
var mapImages = new tempHash();
var iconimages = {};
iconimages.apImage = new Image;
iconimages.apImage.src = "resource/image/icon_ap.png";

iconimages.apExtImage = new Image;
iconimages.apExtImage.src = "resource/image/icon_ap_ext.png";

iconimages.apDirectImage = new Image;
iconimages.apDirectImage.src = "resource/image/icon_ap_direct.png";

iconimages.atImage = new Image;
iconimages.atImage.src = "resource/image/antenna_direction.png";

iconimages.omniatImage = new Image;
iconimages.omniatImage.src = "resource/image/antenna_omni2.png";

iconimages.apleft = new Image;
iconimages.apleft.src = "resource/image/arrow_left.png";

iconimages.apright = new Image;
iconimages.apright.src = "resource/image/arrow_right.png";

iconimages.aptop = new Image;
iconimages.aptop.src = "resource/image/arrow_top.png";

iconimages.apbottom = new Image;
iconimages.apbottom.src = "resource/image/arrow_bottom.png";

function doKeyUp(e) {
	var keyID = e.keyCode ? e.keyCode : e.which;
	if (keyID == 17)
		isCtrl = false;
	if (keyID == 16)
		isShift = false;
}
function doKeyDown(e) {

	e = (e) ? e : ((window.event) ? window.event : "");
	var keyID = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;

	if (keyID == 17) {

		isCtrl = true;
	}
	if (keyID == 16) {

		isShift = true;
	}
	if (keyID == 27) {
		if (currObType === TYPE_DRAW_Rule)
			cancelScale();
	}
	if (keyID == 46) {
		if (currObj != null)
			deleteObj();

	}
	// ctrl+z
	if (keyID == 90 && e.ctrlKey == true) {
		undoDraw();
	}
	if (currObj == null)
		return;

	var space = 1;
	if (keyID === 38) { // up arrow

		/*
		 * if (currObj.obType === TYPE_RECT_WALL) { if (currObj.py - space <
		 * workarea.py || currObj.ph - space < workarea.py) return; } else if
		 * (currObj.apId) { if (currObj.py - space - SIDELENGTH_AP <
		 * workarea.py) return; } else { if (currObj.py - space < workarea.py)
		 * return; }
		 */

		currObj.py -= space;
		if (currObj.obType === TYPE_RECT_WALL)
			currObj.ph -= space;

		if ((currObj.obType === TYPE_RECT_ZONE || currObj.obType === TYPE_RECT_AREA)
				&& !checkOverlap(currObj)) {
			currObj.py += space;
		} else if ((currObj.apId) && !checkAPExclusion(currObj)) {
			currObj.py += space;
		} else {
			if (currObj.obId) {
				FloorUpdateOb(currObj);

			} else if (currObj.atId) {
				FloorUpdateAt(currObj);

			} else if (currObj.apId) {
				FloorUpdateAp(currObj);
			}
			obstructions.push(currObj.Id, currObj);
			resetMaincontext();
		}
		e.preventDefault();
	}
	if (keyID === 39) { // right arrow

		/*
		 * if (currObj.obType === TYPE_RECT_WALL) { if (currObj.px + space >
		 * workarea.px + workarea.pw || currObj.pw + space > workarea.px +
		 * workarea.pw) return; } else if (currObj.apId) { if (currObj.px +
		 * space + SIDELENGTH_AP > workarea.px + workarea.pw) return; } else {
		 * if (currObj.px + space + currObj.pw > workarea.px + workarea.pw)
		 * return; }
		 */

		currObj.px += space;
		if (currObj.obType === TYPE_RECT_WALL)
			currObj.pw += space;

		if ((currObj.obType === TYPE_RECT_ZONE || currObj.obType === TYPE_RECT_AREA)
				&& !checkOverlap(currObj)) {
			currObj.px -= space;
		} else if ((currObj.apId || currObj.atId) && !checkAPExclusion(currObj)) {
			currObj.px -= space;
		} else {
			if (currObj.obId) {
				FloorUpdateOb(currObj);
			} else if (currObj.atId) {
				FloorUpdateAt(currObj);
			} else if (currObj.apId) {
				FloorUpdateAp(currObj);
			}
			obstructions.push(currObj.Id, currObj);
			resetMaincontext();
		}
		e.preventDefault();
	}
	if (keyID === 40) { // down arrow

		/*
		 * if (currObj.obType === TYPE_RECT_WALL) { if (currObj.py + space >
		 * workarea.py + workarea.ph || currObj.ph + space > workarea.py +
		 * workarea.ph) return; } else if (currObj.apId) { if (currObj.py +
		 * space + SIDELENGTH_AP > workarea.py + workarea.ph) return; } else {
		 * if (currObj.py + space + currObj.ph > workarea.py + workarea.ph)
		 * return; }
		 */
		currObj.py += space;
		if (currObj.obType === TYPE_RECT_WALL)
			currObj.ph += space;

		if ((currObj.obType === TYPE_RECT_ZONE || currObj.obType === TYPE_RECT_AREA)
				&& !checkOverlap(currObj)) {
			currObj.py -= space;
		} else if ((currObj.apId || currObj.atId) && !checkAPExclusion(currObj)) {
			currObj.py -= space;
		} else {
			if (currObj.obId) {
				FloorUpdateOb(currObj);
			} else if (currObj.atId) {
				FloorUpdateAt(currObj);
			} else if (currObj.apId) {
				FloorUpdateAp(currObj);
			}
			obstructions.push(currObj.Id, currObj);
			resetMaincontext();
		}
		e.preventDefault();
	}
	if (keyID === 37) { // left arrow

		/*
		 * if (currObj.obType === TYPE_RECT_WALL) { if (currObj.px - space <
		 * workarea.px || currObj.pw - space < workarea.px) return; } else if
		 * (currObj.apId) { if (currObj.px - space - SIDELENGTH_AP <
		 * workarea.px) return; } else { if (currObj.px - space < workarea.px)
		 * return; }
		 */
		currObj.px -= space;
		if (currObj.obType === TYPE_RECT_WALL)
			currObj.pw -= space;

		if ((currObj.obType === TYPE_RECT_ZONE || currObj.obType === TYPE_RECT_AREA)
				&& !checkOverlap(currObj)) {
			currObj.px += space;
		} else if ((currObj.apId || currObj.atId) && !checkAPExclusion(currObj)) {
			currObj.px += space;
		} else {
			if (currObj.obId) {
				FloorUpdateOb(currObj);
			} else if (currObj.atId) {
				FloorUpdateAt(currObj);
			} else if (currObj.apId) {
				FloorUpdateAp(currObj);
			}
			obstructions.push(currObj.Id, currObj);
			resetMaincontext();
		}
		e.preventDefault();
	}
}

function drawzone(obField) {
	currObType = TYPE_RECT_ZONE;
	rulerline = {};
	currObField = obField;
	if (!global.objshow.zone) {
		changeShow($("#menuLayerSub ul li a:eq(0)"), 'zone');
	}
	var style = getRectColor(currObField, 2);
	showEditToolbar(style, "Add", obText[obField]);
	onDrawState();
	resetMaincontext();
};

function drawwall(obField, obRate) {
	currObType = TYPE_RECT_WALL;
	rulerline = {};
	currObField = obField;
	currObRate = obRate;
	if (!global.objshow.obstacle) {
		changeShow($("#menuLayerSub ul li a:eq(1)"), 'obstacle');
	}
	var style = getRectColor(currObField, 2);
	showEditToolbar(style, "Add Obstacle", obText[obField].replace("%s",
			obRate));
	onDrawState();
	resetMaincontext();
};

function drawarea(obField, obRate) {
	currObType = TYPE_RECT_AREA;
	rulerline = {};
	currObField = obField;
	currObRate = obRate;
	if (!global.objshow.area) {
		changeShow($("#menuLayerSub ul li a:eq(2)"), 'area');
	}
	var style = getRectColor(currObField, 2);
	showEditToolbar(style, "Add Area", obText[obField].replace("%s", obRate));
	onDrawState();
	resetMaincontext();
};

function changeHand() {
	undolist = [];
	undoChg();
	hideEditToolbar();
	onMovingState();
}

function changeRuleBtnClick() {
	$(".floor_topmenu").css("display", "none");
	$("#scalepanel").css("display", "block");
	$("#setscaleStart").css("display", "none");
	$("#menuDiv").css("display", "none");
	$("#scaled").attr("disabled", "disabled");
	$("#scaled").val("");
	$("#unit").attr("disabled", "disabled");
	$("#scaleapply").attr("disabled", "disabled");
	$("#redrawscale").css("display", "none");
	$("#scalectl").attr("class", "scalectl_normal");
	$("#resetscalebtn").hide();
	common.changeDivHeight();
	currObType = TYPE_DRAW_Rule;
	ruleline = {};
	rulerline = {};
	changeShowHeatMap('Off');
	resetMaincontext();
	onDrawState();
}

function gridShowBtnClick() {
	showdegree = !showdegree;
	if (showdegree) {
		$("#gridShow").text("Hide Grid");
	} else {
		$("#gridShow").text("Show Grid");
	}
	resetHeatcontext();
}

$("#zoomvalue").click(function() {
	resetScale();
});

$("#zoomin").click(function() {
	canvasBigger();
});

$("#zoomout").click(function() {
	canvasSmaller();
});

$("#reverse").click(function() {
	global.colorOpp = !global.colorOpp;
	if (global.colorOpp) {
		$("#color").hide();
		$("#colorOpp").show();
	} else {
		$("#colorOpp").hide();
		$("#color").show();
	}
	resetHeatcontext();
});

function undoChg() {
	if (undolist.length <= 0) {
		$("#undobtn").hide();
	} else {
		$("#undobtn").show();
		$("#donebtn").show();
	}
}

/**
 * 画布放大缩小时按钮样式的变化
 */
function zoomChg() {

	var resetResultFlag = global.canvasScale != 1
			|| global.translateOffX != initialOffX
			|| global.translateOffY != initialOffY;
	var outResultFlag = global.canvasScale < 6
			&& (global.rulescale == 0 || global.canvasScale <= 50 / global.rulescale);
	var inResultFlag = global.canvasScale > 0.6;
	if (resetResultFlag) {
		$("div#zoomReset a").removeClass("disabledChg");
	} else {
		$("div#zoomReset a").attr("class", "disabledChg");
	}
	if (inResultFlag) {
		$("div#zoomLarger a").removeClass("disabledChg");
	} else {
		$("div#zoomLarger a").attr("class", "disabledChg");
	}
	if (outResultFlag) {
		$("div#zoomSmaller a").removeClass("disabledChg");
	} else {
		$("div#zoomSmaller a").attr("class", "disabledChg");
	}
	$("#zoomvalue").text(Math.round(global.canvasScale * 100) + "%");

}

/**
 * 获取鼠标屏幕坐标位置，考虑了浏览器兼容性
 * 
 * @param e
 * @returns {Point}
 */
function getPointerPosition(e) {
	e = e || getEventObject(e);
	var x = e.pageX
			|| (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft));
	var y = e.pageY
			|| (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop));
	return new Point(x, y);
}

/**
 * 判断x,y点是否位于rect矩形框里
 * 
 * @param x
 * @param y
 * @param rect
 * @returns {Boolean}
 */
function inRect(x, y, rect) {
	return (rect.px + rect.pw - x) * (rect.px - x) < 0
			&& (rect.py + rect.ph - y) * (rect.py - y) < 0;
}

/**
 * 根据前后两个坐标设定矩形的值，使矩形左上角坐标是pxpy,右下角坐标是pwph
 * 
 * @param rect
 * @param loc1
 * @param loc2
 */
function setValue(rect, loc1, loc2) {

	rect.pw = Math.abs(loc2.x - loc1.x);
	rect.ph = Math.abs(loc2.y - loc1.y);
	if (isShift) {

		if (loc2.x < loc1.x) {
			if (loc2.y < loc1.y) {
				if (rect.pw > rect.ph) {
					rect.px = loc2.x + rect.pw - rect.ph;
					rect.py = loc2.y;
				} else {
					rect.px = loc2.x;
					rect.py = loc2.y + rect.ph - rect.pw;
				}

			} else {
				if (rect.pw > rect.ph) {
					rect.px = loc2.x + rect.pw - rect.ph;
					rect.py = loc2.y - rect.ph;
				} else {
					rect.px = loc2.x;
					rect.py = loc2.y - rect.ph;
				}

			}
		} else {
			if (loc2.y < loc1.y) {
				rect.px = loc1.x;
				rect.py = loc2.y;
				// rect.py = loc2.y + rect.ph - rect.pw;

			} else {
				rect.px = loc1.x;
				rect.py = loc1.y;
			}
		}
		if (rect.pw > rect.ph) {
			rect.pw = rect.ph;
		} else {
			rect.ph = rect.pw;
		}
	} else {
		if (loc2.x > loc1.x)
			rect.px = loc1.x;
		else
			rect.px = loc2.x;

		if (loc2.y > loc1.y)
			rect.py = loc1.y;
		else
			rect.py = loc2.y;
	}

}

/**
 * 获取旋转后的坐标位置
 * 
 * @param loc
 *            原始坐标
 * @param center
 *            旋转中心点
 * @param rotate
 *            旋转角度
 * @returns {Point}
 */
function getRotateLoc(loc, center, rotate) {

	var x = Math.cos(rotate) * (loc.x - center.x) - Math.sin(rotate)
			* (loc.y - center.y) + center.x;
	var y = Math.sin(rotate) * (loc.x - center.x) + Math.cos(rotate)
			* (loc.y - center.y) + center.y;
	return new Point(x, y);
}

var Point = function(x, y) {
	this.x = x;
	this.y = y;
};

/**
 * 主窗体变化引起画布大小自动变化
 * 
 * @param width
 * @param height
 */
function canvasAutoresize() {

	var bbox = maincontext.canvas.getBoundingClientRect();
	var width = bbox.width, height = bbox.height;

	initialOffX = width / 2;
	initialOffY = height / 2;

	maincontext.canvas.width = width;
	maincontext.canvas.height = height;
	backcontext.canvas.width = width;
	backcontext.canvas.height = height;

	// global.canvasScale = 1;
	calculateStep(global);
	resetHeatcontext();
	resetMaincontext();
	zoomChg();
}

/**
 * 当前鼠标按下的位置是否可以画界面元素
 * 
 * @param loc
 */
function ifCandraw(loc) {

	var allowed = true;
	if (currObType == TYPE_DRAW_Rule || currObType == TYPE_DRAW_Ruler)
		return allowed;
	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;
		if (currObType == TYPE_RECT_WALL)
			return;
		if (currObType == TYPE_RECT_AREA && value.obType !== currObType)
			return;
		if (currObType == TYPE_RECT_ZONE && value.obField !== currObField)
			return;

		if (inRect(loc.x, loc.y, value)) {
			allowed = false;
		}
	});

	return allowed;
}

var GuideLine = function(coordinate, direction, distance) {
	this.Coordinate = coordinate;
	this.Direction = direction;
	this.Distance = distance;
};

/**
 * 自动垂直或水平
 * 
 * @param obstacle
 */
function wallAutoAdjustment(obstacle) {

	if (Math.abs(obstacle.px - obstacle.pw) < MINISTEP) {
		// 倾斜弧长小于某长度，自动垂直
		obstacle.pw = obstacle.px;
	} else if (Math.abs(obstacle.py - obstacle.ph) < MINISTEP) {
		// 倾斜弧长小于某长度，自动水平
		obstacle.ph = obstacle.py;
	}

}

/**
 * 移动障碍物时自动移动位置使其与其它可编辑元素对齐，并出现辅助线
 */
function wallAutoMove(obstacle) {

	if (obstacle == null)
		return;

	var guidLines = new tempHash();

	$.each(obstructions.options, function(index, value) {

		if (!value || !value.obType)
			return;
		if (value.Id == obstacle.Id)
			return;

		if (value.obType == TYPE_RECT_WALL) {

			checkWallGUide(obstacle, value);

		} else if (value.obType == TYPE_RECT_ZONE
				|| value.obType == TYPE_RECT_AREA) {

			checkZoneGUide(obstacle, value);
		}

	});

	function checkWallGUide(obstacle, value) {

		if (Math.abs(obstacle.py - value.py) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.py - value.py);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.ph = obstacle.ph + value.py - obstacle.py;
				obstacle.py = value.py;
				guidLines.push("y", new GuideLine(obstacle.py, "y", distance));
			}

		}
		if (Math.abs(obstacle.py - value.ph) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.py - value.ph);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.ph = obstacle.ph + value.ph - obstacle.py;
				obstacle.py = value.ph;
				guidLines.push("y", new GuideLine(obstacle.py, "y", distance));
			}

		}
		if (Math.abs(obstacle.ph - value.py) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.ph - value.py);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.py = obstacle.py + value.py - obstacle.ph;
				obstacle.ph = value.py;
				guidLines.push("y", new GuideLine(obstacle.ph, "y", distance));
			}

		}
		if (Math.abs(obstacle.ph - value.ph) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.ph - value.ph);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.py = obstacle.py + value.ph - obstacle.ph;
				obstacle.ph = value.ph;
				guidLines.push("y", new GuideLine(obstacle.ph, "y", distance));
			}
		}

		if (Math.abs(obstacle.px - value.px) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.px - value.px);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.pw = obstacle.pw + value.px - obstacle.px;
				obstacle.px = value.px;
				guidLines.push("x", new GuideLine(obstacle.px, "x", distance));
			}

		}
		if (Math.abs(obstacle.px - value.pw) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.px - value.pw);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.pw = obstacle.pw + value.pw - obstacle.px;
				obstacle.px = value.pw;
				guidLines.push("x", new GuideLine(obstacle.px, "x", distance));
			}

		}
		if (Math.abs(obstacle.pw - value.px) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.pw - value.px);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.px = obstacle.px + value.px - obstacle.pw;
				obstacle.pw = value.px;
				guidLines.push("x", new GuideLine(obstacle.pw, "x", distance));
			}

		}
		if (Math.abs(obstacle.pw - value.pw) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.pw - value.pw);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.px = obstacle.px + value.pw - obstacle.pw;
				obstacle.pw = value.pw;
				guidLines.push("x", new GuideLine(obstacle.pw, "x", distance));
			}

		}
	}

	function checkZoneGUide(obstacle, value) {
		if (Math.abs(obstacle.py - value.py) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.py - value.py);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.ph = obstacle.ph + value.py - obstacle.py;
				obstacle.py = value.py;
				guidLines.push("y", new GuideLine(obstacle.py, "y", distance));
			}

		}
		if (Math.abs(obstacle.py - value.py - value.ph) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.py - value.py - value.ph);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.ph = obstacle.ph + value.py + value.ph - obstacle.py;
				obstacle.py = value.py + value.ph;
				guidLines.push("y", new GuideLine(obstacle.py, "y", distance));
			}

		}
		if (Math.abs(obstacle.ph - value.py) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.ph - value.py);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.py = obstacle.py + value.py - obstacle.ph;
				obstacle.ph = value.py;
				guidLines.push("y", new GuideLine(obstacle.ph, "y", distance));
			}

		}
		if (Math.abs(obstacle.ph - value.py - value.ph) < MINISTEP) {

			var oldGuideLine = guidLines.get("y");
			var distance = Math.abs(obstacle.ph - value.py - value.ph);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.py = obstacle.py + value.py + value.ph - obstacle.ph;
				obstacle.ph = value.py + value.ph;
				guidLines.push("y", new GuideLine(obstacle.ph, "y", distance));
			}

		}

		if (Math.abs(obstacle.px - value.px) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.px - value.px);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.pw = obstacle.pw + value.px - obstacle.px;
				obstacle.px = value.px;
				guidLines.push("x", new GuideLine(obstacle.px, "x", distance));
			}

		}
		if (Math.abs(obstacle.px - value.px - value.pw) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.px - value.px - value.pw);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.pw = obstacle.pw + value.px + value.pw - obstacle.px;
				obstacle.px = value.px + value.pw;
				guidLines.push("x", new GuideLine(obstacle.px, "x", distance));
			}

		}
		if (Math.abs(obstacle.pw - value.px) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.pw - value.px);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.px = obstacle.px + value.px - obstacle.pw;
				obstacle.pw = value.px;
				guidLines.push("x", new GuideLine(obstacle.pw, "x", distance));
			}

		}
		if (Math.abs(obstacle.pw - value.px - value.pw) < MINISTEP) {

			var oldGuideLine = guidLines.get("x");
			var distance = Math.abs(obstacle.pw - value.px - value.pw);
			if (oldGuideLine == null || oldGuideLine.Distance > distance) {
				obstacle.px = obstacle.px + value.px + value.pw - obstacle.pw;
				obstacle.pw = value.px + value.pw;
				guidLines.push("x", new GuideLine(obstacle.pw, "x", distance));
			}
		}
	}

	return guidLines;
}

/**
 * draw或resize的时候自动调整大小，障碍物或区间都适应
 * 
 * @param loc
 * @returns {tempHash}
 */
function AutoAdjustment(loc) {

	var guidLines = new tempHash();

	function autoAdjustmentMethord(loc, value2, key, type) {

		if (key == "y") {
			if (Math.abs(loc.y - value2) < MINISTEP) {

				var oldGuideLine = guidLines.get(key);
				var distance = Math.abs(loc.y - value2);
				if (oldGuideLine == null || oldGuideLine.Distance > distance) {
					loc.y = value2;
					guidLines.push(key, new GuideLine(value2, key, distance));
				}

			}
		} else if (key == "x") {
			if (Math.abs(loc.x - value2) < MINISTEP) {

				var oldGuideLine1 = guidLines.get(key);
				var distance1 = Math.abs(loc.x - value2);
				if (oldGuideLine1 == null || oldGuideLine1.Distance > distance1) {
					loc.x = value2;
					guidLines.push(key, new GuideLine(value2, key, distance1));
				}

			}

		}
	}
	$.each(obstructions.options, function(index, value) {

		if (!value || !value.obType)
			return;

		if (currObj != null && value.Id === currObj.Id)
			return;

		if (value.obType == TYPE_RECT_WALL) {

			autoAdjustmentMethord(loc, value.py, "y");
			autoAdjustmentMethord(loc, value.ph, "y");

			autoAdjustmentMethord(loc, value.px, "x");
			autoAdjustmentMethord(loc, value.pw, "x");

		} else if (value.obType == TYPE_RECT_ZONE
				|| value.obType == TYPE_RECT_AREA) {

			autoAdjustmentMethord(loc, value.py, "y");
			autoAdjustmentMethord(loc, value.py + value.ph, "y");

			autoAdjustmentMethord(loc, value.px, "x");
			autoAdjustmentMethord(loc, value.px + value.pw, "x");

		}
	});

	return guidLines;
}

/**
 * 区域移动时与其它可编辑界面元素自动对齐
 * 
 * @param obstacle
 * @returns {tempHash}
 */
function zoneAutoMove(obstacle) {

	if (obstacle == null)
		return;
	var guidLines = new tempHash();

	$.each(obstructions.options, function(index, value) {

		if (!value || !value.obType)
			return;
		if (value.Id == obstacle.Id)
			return;

		if (value.obType == TYPE_RECT_WALL) {

			checkWallGUide(obstacle, value);

		} else if (value.obType == TYPE_RECT_ZONE
				|| value.obType == TYPE_RECT_AREA) {

			checkZoneGUide(obstacle, value);
		}

	});

	function autoAdjustmentMethord(obstacle, value2, value3, key) {

		if (key == "y") {
			if (Math.abs(obstacle.py - value2 + value3) < MINISTEP) {

				var oldGuideLine = guidLines.get(key);
				var distance = Math.abs(obstacle.py - value2);
				if (oldGuideLine == null || oldGuideLine.Distance > distance) {
					obstacle.py = value2 - value3;
					guidLines.push(key, new GuideLine(obstacle.py + value3,
							key, distance));
				}

			}
		} else if (key == "x") {
			if (Math.abs(obstacle.px - value2 + value3) < MINISTEP) {

				var oldGuideLine1 = guidLines.get(key);
				var distance1 = Math.abs(obstacle.px - value2);
				if (oldGuideLine1 == null || oldGuideLine1.Distance > distance1) {
					obstacle.px = value2 - value3;
					guidLines.push(key, new GuideLine(obstacle.px + value3,
							key, distance1));
				}

			}

		}
	}

	function checkWallGUide(obstacle, value) {

		autoAdjustmentMethord(obstacle, value.py, 0, "y");

		autoAdjustmentMethord(obstacle, value.ph, 0, "y");

		autoAdjustmentMethord(obstacle, value.py, obstacle.ph, "y");

		autoAdjustmentMethord(obstacle, value.ph, obstacle.ph, "y");

		autoAdjustmentMethord(obstacle, value.px, 0, "x");

		autoAdjustmentMethord(obstacle, value.pw, 0, "x");

		autoAdjustmentMethord(obstacle, value.px, obstacle.pw, "x");

		autoAdjustmentMethord(obstacle, value.pw, obstacle.pw, "x");

	}

	function checkZoneGUide(obstacle, value) {

		autoAdjustmentMethord(obstacle, value.py, 0, "y");

		autoAdjustmentMethord(obstacle, value.py + value.ph, 0, "y");

		autoAdjustmentMethord(obstacle, value.py, obstacle.ph, "y");

		autoAdjustmentMethord(obstacle, value.py + value.ph, obstacle.ph, "y");

		autoAdjustmentMethord(obstacle, value.px, 0, "x");

		autoAdjustmentMethord(obstacle, value.px + value.pw, 0, "x");

		autoAdjustmentMethord(obstacle, value.px, obstacle.pw, "x");

		autoAdjustmentMethord(obstacle, value.px + value.pw, obstacle.pw, "x");

	}

	return guidLines;
}

function drawGuideLine(guideLine) {

	maincontext.save();
	maincontext.lineWidth = WIDTH_GUIDE;
	maincontext.strokeStyle = COLOR_GUIDE;

	if (guideLine.Direction == "y") {

		drawDashedLine(0 - global.translateOffX, guideLine.Coordinate,
				maincontext.canvas.width - global.translateOffX,
				guideLine.Coordinate, maincontext);
	}
	if (guideLine.Direction == "x") {

		drawDashedLine(guideLine.Coordinate, 0 - global.translateOffY,
				guideLine.Coordinate, maincontext.canvas.height
						- global.translateOffY, maincontext);
	}
	maincontext.restore();
}

/**
 * 计算网格单元数据
 */
function calculateStep(options) {
	if (options.rulescale <= 0)
		return;

	options.stepmeterfeet = parseInt(72 / options.canvasScale
			* options.rulescale);
	if (options.stepmeterfeet <= 0) {
		options.stepmeterfeet = (72 / options.canvasScale * options.rulescale)
				.toFixed(1);
		if (options.stepmeterfeet <= 0) {
			options.stepmeterfeet = 0.1;
		}
	}

	options.stepPX = options.stepmeterfeet * options.canvasScale
			/ options.rulescale;

};

/**
 * 画比例尺图例
 */
function drawRule(context, stepPX, stepmeterfeet, ruleunit) {

	var bottom = context.canvas.height - 20;
	var left = 20;
	context.save();
	context.lineWidth = 2;
	context.strokeStyle = '#666';
	drawLine(stepPX * 3 + 20, bottom, left, bottom, context);
	drawLine(stepPX * 3 + 20, bottom - 4, stepPX * 3 + 20, bottom + 4, context);
	drawLine(stepPX * 2 + 20, bottom - 4, stepPX * 2 + 20, bottom + 4, context);
	drawLine(stepPX * 1 + 20, bottom - 4, stepPX * 1 + 20, bottom + 4, context);
	drawLine(left, bottom - 4, left, bottom + 4, context);

	context.lineWidth = 5;
	drawLine(stepPX * 3 + 20, bottom, stepPX * 2 + 20, bottom, context);
	drawLine(stepPX * 1 + 20, bottom, 20, bottom, context);

	context.fillStyle = '#666';
	context.font = "12px Arial";
	context.fillText(0, left - 3, bottom - 10);
	context.fillText(checkNum(stepmeterfeet * 1), left + stepPX - 3,
			bottom - 10);
	context.fillText(checkNum(stepmeterfeet * 2), left + stepPX * 2 - 3,
			bottom - 10);
	context.fillText(
			checkNum(stepmeterfeet * 3) + (ruleunit == 0 ? "m" : "ft"), left
					+ stepPX * 3 - 3, bottom - 10);

	context.restore();

	function checkNum(num) {
		if (parseInt(num) == num)
			return num;
		else
			return num.toFixed(1);
	}

}

/**
 * 根据天线对应的APID查找对应的天线对象
 * 
 * @param apId
 * @returns
 */
function getatbyapId(apId) {

	var find = null;
	if (global.currentFloor.floorType == 0) {
		$.each(obstructions.options, function(index, value) {
			if (value != null && value.atId && value.apId == apId)
				find = value;
		});
	} else {
		if (googleMap.bind.atList) {
			googleMap.bind.atList.forEach(function(at) {
				if (at.apId == apId) {
					find = at;
				}
			});
		}
	}
	return find;

};

/**
 * 判断区域是否重叠 只判断，不会自动裁剪 调整区域大小和移动区域对象松口鼠标时判断调用
 * 
 * @param obstruction
 * @returns {Boolean}
 */
function checkOverlap(obstruction) {

	var result = true;
	$
			.each(
					obstructions.options,
					function(index, value) {
						if (value == null)
							return;

						if (value.Id == obstruction.Id)
							return;

						if ((obstruction.obType == TYPE_RECT_AREA && value.obType == obstruction.obType)
								|| (obstruction.obType == TYPE_RECT_ZONE && value.obField == obstruction.obField)) {

							var centerAx = value.px + value.pw / 2;
							var centerAy = value.py + value.ph / 2;
							var centerBx = obstruction.px + obstruction.pw / 2;
							var centerBy = obstruction.py + obstruction.ph / 2;

							if (Math.abs(centerBx - centerAx) < value.pw / 2
									+ obstruction.pw / 2
									&& Math.abs(centerBy - centerAy) < value.ph
											/ 2 + obstruction.ph / 2) {
								result = false;
							}

						}

					});

	return result;

};

/**
 * 矩形区域重叠判断 zone，area不能自我重叠 有些重叠可通过自动裁剪大小达到允许的目的 画一个新的区域松口鼠标时判断调用
 * 
 * @param obstruction
 * @returns {Boolean}
 */
function checkRectangle(obstruction) {

	var result = true;
	$
			.each(
					obstructions.options,
					function(index, value) {
						if (value == null)
							return;

						if ((obstruction.obType == TYPE_RECT_AREA && value.obType == obstruction.obType)
								|| (obstruction.obType == TYPE_RECT_ZONE && value.obField == obstruction.obField)) {

							if ((inRect(value.px, value.py, obstruction) && inRect(
									value.px + value.pw, value.py, obstruction))
									|| (inRect(value.px, value.py, obstruction) && inRect(
											value.px, value.py + value.ph,
											obstruction))
									|| (inRect(value.px + value.pw, value.py
											+ value.ph, obstruction) && inRect(
											value.px + value.pw, value.py,
											obstruction))
									|| (inRect(value.px + value.pw, value.py
											+ value.ph, obstruction) && inRect(
											value.px, value.py + value.ph,
											obstruction))) {
								result = false;
							} else if (inRect(obstruction.px, obstruction.py,
									value)
									&& inRect(obstruction.px + obstruction.pw,
											obstruction.py, value)) {
								obstruction.ph = obstruction.py
										+ obstruction.ph - value.py - value.ph;
								obstruction.py = value.py + value.ph;
							} else if (inRect(obstruction.px, obstruction.py,
									value)
									&& inRect(obstruction.px, obstruction.py
											+ obstruction.ph, value)) {
								obstruction.pw = obstruction.px
										+ obstruction.pw - value.px - value.pw;
								obstruction.px = value.px + value.pw;
							} else if (inRect(obstruction.px + obstruction.pw,
									obstruction.py + obstruction.ph, value)
									&& inRect(obstruction.px + obstruction.pw,
											obstruction.py, value)) {
								obstruction.pw = value.px - obstruction.px;
							} else if (inRect(obstruction.px + obstruction.pw,
									obstruction.py + obstruction.ph, value)
									&& inRect(obstruction.px, obstruction.py
											+ obstruction.ph, value)) {
								obstruction.ph = value.py - obstruction.py;
							} else if (inRect(obstruction.px, obstruction.py,
									value)) {

								if (obstruction.px + obstruction.pw - value.px
										- value.pw > obstruction.py
										+ obstruction.ph - value.py - value.ph) {
									obstruction.pw = obstruction.pw - value.px
											- value.pw + obstruction.px;
									obstruction.px = value.px + value.pw;
								} else {
									obstruction.ph = obstruction.ph - value.py
											- value.ph + obstruction.py;
									obstruction.py = value.py + value.ph;
								}

							} else if (inRect(obstruction.px + obstruction.pw,
									obstruction.py, value)) {
								if (value.px - obstruction.px > obstruction.py
										+ obstruction.ph - value.py - value.ph) {
									obstruction.pw = value.px - obstruction.px;
								} else {
									obstruction.ph = obstruction.ph - value.py
											- value.ph + obstruction.py;
									obstruction.py = value.py + value.ph;
								}

							} else if (inRect(obstruction.px, obstruction.py
									+ obstruction.ph, value)) {
								if (value.py - obstruction.py > obstruction.px
										+ obstruction.pw - value.px - value.pw) {
									obstruction.ph = value.py - obstruction.py;
								} else {
									obstruction.pw = obstruction.pw - value.px
											- value.pw + obstruction.px;
									obstruction.px = value.px + value.pw;
								}

							} else if (inRect(obstruction.px + obstruction.pw,
									obstruction.py + obstruction.ph, value)) {
								if (value.py - obstruction.py > value.px
										- obstruction.px) {
									obstruction.ph = value.py - obstruction.py;
								} else {
									obstruction.pw = value.px - obstruction.px;
								}

							} else {
								var centerAx = value.px + value.pw / 2;
								var centerAy = value.py + value.ph / 2;
								var centerBx = obstruction.px + obstruction.pw
										/ 2;
								var centerBy = obstruction.py + obstruction.ph
										/ 2;

								if (Math.abs(centerBx - centerAx) < value.pw
										/ 2 + obstruction.pw / 2
										&& Math.abs(centerBy - centerAy) < value.ph
												/ 2 + obstruction.ph / 2) {
									result = false;
								}
							}
						}

					});

	return result;

};

/**
 * 是否有AP或天线与当前区域冲突
 * 
 * @param obstruction
 * @returns {Boolean}
 */
function checkExclusionAP(obstruction) {

	var result = true;
	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;
		if (value.apId || value.atId) {
			if (obstruction.obType == TYPE_RECT_ZONE
					&& obstruction.obField == OBFIELD_EXCLUSION) {
				if (inRect(value.px, value.py, obstruction)) {
					result = false;
				}
			} else if (obstruction.obType == TYPE_RECT_AREA
					&& obstruction.obField == OBFIELD_ELEVATOR) {
				if (inRect(value.px, value.py, obstruction)) {
					result = false;
				}
			}
		}

	});

	return result;

};

/**
 * 是否有区域与当前AP或天线冲突
 * 
 * @param ap
 * @returns {Boolean}
 */
function checkAPExclusion(ap) {

	var result = true;

	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;

		if (value.obType == TYPE_RECT_ZONE
				&& value.obField == OBFIELD_EXCLUSION) {
			if (inRect(ap.px, ap.py, value)) {
				result = false;
			}
		} else if (value.obType == TYPE_RECT_AREA
				&& value.obField == OBFIELD_ELEVATOR) {
			if (inRect(ap.px, ap.py, value)) {
				result = false;
			}
		}

	});

	return result;

};

/**
 * 
 * @param dellist
 *            被删除的AP的apId的数组
 * @param uplist
 *            需要更新的AP的数组
 */
function inventoryRefresh(dellist, uplist) {

	for (var i = 0; i < dellist.length; i++) {
		var delId = dellist[i].apId;
		var delap = obstructions.get(delId);
		if (delap != null) {
			var at = getatbyapId(delId);
			if (at != null) {
				obstructions.push(at.atId, null);
			}
			obstructions.push(delId, null);
		}
	}

	for (var j = 0; j < uplist.length; j++) {
		var upId = uplist[j].apId;
		var upap = obstructions.get(upId);
		if (upap != null) {
			var ap = new AP(uplist[j]);
			obstructions.push(upId, ap);
		}
	}

	setCurrObj(null);
	resetHeatcontext();
	resetMaincontext();
	changeMenuStatus();
}

function propertyRefresh() {
	var ap = new AP(global.currentAP);
	obstructions.push(global.currentAP.Id, ap);
	setCurrObj(global.currentAP);
	resetHeatcontext();
	resetMaincontext();
}

/**
 * 
 * @param addAPList
 * @param addAtList
 */
function advisorRefresh(addAPList, addAtList) {

	$.each(obstructions.options, function(index, value) {

		if (!value)
			return;

		if (value.atId) {
			obstructions.push(value.atId, null);
		} else if (value.apId) {
			obstructions.push(value.apId, null);
		} else
			return;

	});
	for (var j = 0; j < addAtList.length; j++) {

		var atId = addAtList[j].atId;
		obstructions.push(atId, new Antenna(addAtList[j]));

	}
	for (var i = 0; i < addAPList.length; i++) {

		var apId = addAPList[i].apId;
		var ap = new AP(addAPList[i]);
		obstructions.push(apId, ap);

	}

	setCurrObj(null);
	resetHeatcontext();
	resetMaincontext();
	changeMenuStatus();
}
/**
 * auto channel 和auto replacement advisor 的刷新
 * 
 * @param uplist
 *            更新的AP列表
 * @param action
 *            autochannel replacement
 */
function autoRefresh(uplist, atlist, action) {
	if (atlist != null) {
		for (var j = 0; j < atlist.length; j++) {

			var atId = atlist[j].atId;
			var upat = obstructions.get(atId);
			if (upat != null) {
				obstructions.push(atId, new Antenna(atlist[j]));
			}

		}
	}
	for (var j = 0; j < uplist.length; j++) {
		var upId = uplist[j].apId;
		var upap = obstructions.get(upId);
		if (upap != null) {
			var ap = new AP(uplist[j]);
			obstructions.push(upId, ap);
		}
	}

	setCurrObj(null);
	resetHeatcontext();
	resetMaincontext();
	changeMenuStatus();
}
function getAllChannels(rf) {

	var result = [];
	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;
		if (!value.apId || value.atId)
			return;
		if (!value.bandList)
			return;
		for (var j = 0; j < this.bandList.length; j++) {
			var band = this.bandList[j];
			if (band.enable == 0) {
				if (band.rf == rf && band.channel != "Auto") {
					if (!result.contains(band.channel))
						result.push(band.channel);
				}
			}
		}
	});
	result.sort(function(a, b) {
		if (a.length > b.length) {
			return 1;
		} else if (a.length == b.length) {
			return a > b ? 1 : -1;
		} else {
			return -1;
		}
	});
	return result;

}
