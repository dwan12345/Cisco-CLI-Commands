/**
 * 临时保存的画布绘图表面数据
 */
var drawingSurfaceImageData = null;
/**
 * 记录鼠标按下事件的位置
 */
var canvasmousedown = {};

var workarea = {};
var heatArray;
var heatStep;

/**
 * 当前操作对象
 */
var currObj = null;

/**
 * 保存一个当前环境变量副本
 */
var contextClone = {};

/**
 * 是否显示刻度
 */
var showdegree = true;

var backcanvas = null;
var maincanvas = null;

var initialOffX = 0;
var initialOffY = 0;

/**
 * 画背景地图、网格和热点的图层
 */
var backcontext = null;
/**
 * 画界面可编辑元素的图层
 */
var maincontext = null;
var tipdiv = document.getElementById("tipdiv");
var tipspan = document.getElementById("tipspan");
var delbtn = document.getElementById("delbtn");
var aprightmenu = document.getElementById("ap-rightmenu");
/**
 * 当前要绘制的对象大类型：zone,wall,area,rule
 */
var currObType = TYPE_RECT_ZONE;
/**
 * 当前要绘制的对象小类型
 */
var currObField = "";

var currObRate = "";

/**
 * 当前floor的对象容器，包括zone,obstacle,area,AP,antenna
 */
var obstructions = new tempHash();

/**
 * 可撤销操作的缓存对象
 */
var undolist = [];

var ruleline = {};
var rulerline = {};
var wdsLine = {};

/**
 * 是否按下了CTRL键
 */
var isCtrl = false;
/**
 * 是否按下了SHIFT键
 */
var isShift = false;

canvasInitial();

function canvasInitial() {

	backcanvas = document.getElementById("backcanvas");
	backcontext = backcanvas.getContext('2d');

	maincanvas = document.getElementById("maincanvas");
	maincontext = maincanvas.getContext('2d');
	maincontext.canvas.style.cursor = 'move';

	window.addEventListener('keydown', doKeyDown, true);
	window.addEventListener('keyup', doKeyUp, true);

	onMovingState();
	resetMaincontext();

}

/**
 * 将绘图表面保存起来
 */
function saveDrawingSurface(x, y) {
	drawingSurfaceImageData = maincontext.getImageData(0, 0,
			maincontext.canvas.width, maincontext.canvas.height);
};

/**
 * 恢复上次保存的绘制表面
 */
function restoreDrawingSurface(x, y) {
	maincontext.putImageData(drawingSurfaceImageData, 0, 0);
};

function transformCanvas(x, y) {
	x -= document.body.scrollLeft;
	y -= document.body.scrollTop;
	var bbox = maincontext.canvas.getBoundingClientRect();

	var xspan = x - bbox.left;
	if (0 < xspan && xspan < 20) {
		global.translateOffX += (20 - xspan)
				* (maincontext.canvas.width / bbox.width) / global.canvasScale;
		zoomChg();
		return true;
	}
	xspan = x - bbox.right;
	if (-20 < xspan && xspan < 0) {
		global.translateOffX += (-20 - xspan)
				* (maincontext.canvas.width / bbox.width) / global.canvasScale;
		zoomChg();
		return true;
	}

	var yspan = y - bbox.top;
	if (0 < yspan && yspan < 20) {
		global.translateOffY += (20 - yspan)
				* (maincontext.canvas.height / bbox.height)
				/ global.canvasScale;
		zoomChg();
		return true;
	}
	yspan = y - bbox.bottom;
	if (-20 < yspan && yspan < 0) {
		global.translateOffY += (-20 - yspan)
				* (maincontext.canvas.height / bbox.height)
				/ global.canvasScale;
		zoomChg();
		return true;
	}
};

function ifInCanvas(x, y) {
	x -= document.body.scrollLeft;
	y -= document.body.scrollTop;
	var bbox = maincontext.canvas.getBoundingClientRect();
	return x < bbox.right && x > bbox.left && y < bbox.bottom && y > bbox.top;
}

/**
 * 将窗口坐标转换成canvas原始坐标
 */
function windowToCanvas(x, y) {
	x -= document.body.scrollLeft;
	y -= document.body.scrollTop;
	var bbox = maincontext.canvas.getBoundingClientRect();
	return {
		x : ((x - bbox.left) * (maincontext.canvas.width / bbox.width) - global.translateOffX)
				/ global.canvasScale,
		y : ((y - bbox.top) * (maincontext.canvas.height / bbox.height) - global.translateOffY)
				/ global.canvasScale
	};
};

/**
 * 将窗口坐标转换成
 */
function windowToMouse(x, y) {
	x -= document.body.scrollLeft;
	y -= document.body.scrollTop;
	var bbox = maincontext.canvas.getBoundingClientRect();
	return {
		x : (x - bbox.left) * (maincontext.canvas.width / bbox.width),
		y : (y - bbox.top) * (maincontext.canvas.height / bbox.height)
	};
};

function onDrawState() {

	maincontext.canvas.style.cursor = 'crosshair';
	global.canvasaction = "none";
	var loc;

	maincontext.canvas.onmousedown = function(e) {

		// 禁止浏览器对该事件做出默认的反应
		e.preventDefault();

		var point = getPointerPosition(e);
		var x = point.x, y = point.y;

		// 记录鼠标按下的位置
		loc = windowToCanvas(x, y);

		canvasmousedown.x = loc.x;
		canvasmousedown.y = loc.y;

		if (global.canvasaction != "addap" && ifCandraw(loc)) {

			setCurrObj(null);
			resetHeatcontext();
			resetMaincontext();
			global.canvasaction = "startdrag";

			contextClone.canvasScale = global.canvasScale;
			contextClone.translateOffX = global.translateOffX;
			contextClone.translateOffY = global.translateOffY;
		}

	};

	maincontext.canvas.onmousemove = function(e) {

		e.preventDefault();

		var point = getPointerPosition(e);
		var x = point.x, y = point.y;

		if (global.canvasaction === "startdrag"
				|| global.canvasaction === "dragging") {

			var temploc = windowToCanvas(x, y);

			loc = temploc;

			if (transformCanvas(x, y))
				resetHeatcontext();
			resetMaincontext();

			if (currObType === TYPE_DRAW_Rule) {
				maincontext.save();
				maincontext.strokeStyle = COLOR_RULE;
				maincontext.lineWidth = WIDTH_RULE;
				maincontext.setTransform(1, 0, 0, 1, 0, 0);
				drawDashedLine(canvasmousedown.x * global.canvasScale
						+ global.translateOffX, canvasmousedown.y
						* global.canvasScale + global.translateOffY, loc.x
						* global.canvasScale + global.translateOffX, loc.y
						* global.canvasScale + global.translateOffY,
						maincontext, 8, 8);
				maincontext.restore();
			} else if (currObType === TYPE_DRAW_Ruler) {
				maincontext.save();
				maincontext.strokeStyle = COLOR_RULER;
				maincontext.lineWidth = 2;
				maincontext.setTransform(1, 0, 0, 1, 0, 0);
				drawDashedLine(canvasmousedown.x * global.canvasScale
						+ global.translateOffX, canvasmousedown.y
						* global.canvasScale + global.translateOffY, loc.x
						* global.canvasScale + global.translateOffX, loc.y
						* global.canvasScale + global.translateOffY,
						maincontext, 8, 8);
				maincontext.fillStyle = COLOR_RULER_FILL;
				maincontext.font = "bold 13px Arial";
				maincontext.lineWidth = 1;

				var distance = Math.sqrt(Math.pow(loc.x - canvasmousedown.x, 2)
						+ Math.pow(loc.y - canvasmousedown.y, 2));
				var txt = (distance * global.rulescale).toFixed(2)
						+ (global.ruleunit == 0 ? "meters" : "ft");
				maincontext.rect((loc.x + 8) * global.canvasScale
						+ global.translateOffX, (loc.y + 8)
						* global.canvasScale + global.translateOffY,
						maincontext.measureText(txt).width + 16, 29);
				maincontext.stroke();
				maincontext.fill();
				maincontext.fillStyle = COLOR_RULER;

				maincontext.fillText(txt, (loc.x + 8) * global.canvasScale
						+ global.translateOffX + 8, (loc.y + 8)
						* global.canvasScale + global.translateOffY + 19);
				maincontext.restore();
			} else if (currObType === TYPE_RECT_WALL) {
				var pw = loc.x;
				var ph = loc.y;
				if (isShift) {
					var w = pw - canvasmousedown.x;
					var h = ph - canvasmousedown.y;
					var length = Math.sqrt(Math.pow(Math.abs(w), 2)
							+ Math.pow(Math.abs(h), 2));

					var flagh = h > 0 ? 1 : -1;
					var flagw = w > 0 ? 1 : -1;
					var angle = Math.atan(Math.abs(h / w));
					if (angle < Math.PI / 8) {
						ph = canvasmousedown.y;
						pw = canvasmousedown.x + length * flagw;
					} else if (angle < Math.PI * 3 / 8) {
						var dis = Math.sqrt(Math.pow(length, 2) / 2);
						ph = canvasmousedown.y + dis * flagh;
						pw = canvasmousedown.x + dis * flagw;
					} else {
						pw = canvasmousedown.x;
						ph = canvasmousedown.y + length * flagh;
					}
				}
				var obstacle = new Obstacle({
					px : canvasmousedown.x,
					py : canvasmousedown.y,
					pw : pw,
					ph : ph,
					obType : currObType,
					obField : currObField,
					rate : currObRate,
					floorId : global.currentFloor.floorId
				});

				if (isShift) {
					obstacle.stroke(maincontext, global);
				} else {// 没有按下SHIFT键时，对齐

					var pointHash = AutoAdjustment(loc);
					obstacle.pw = loc.x;
					obstacle.ph = loc.y;
					wallAutoAdjustment(obstacle);
					obstacle.stroke(maincontext, global);
					$.each(pointHash.options, function(index, value) {
						drawGuideLine(value);
					});
				}
			} else if (currObType === TYPE_RECT_ZONE) {

				var zone = new Zone({
					obType : currObType,
					obField : currObField,
					floorId : global.currentFloor.floorId
				});
				if (isShift) {
					setValue(zone, canvasmousedown, loc);
					zone.stroke(maincontext, global);
					zone.fill(maincontext, global);
				} else {
					var pointHash = AutoAdjustment(loc);
					setValue(zone, canvasmousedown, loc);
					zone.stroke(maincontext, global);
					zone.fill(maincontext, global);
					$.each(pointHash.options, function(index, value) {
						drawGuideLine(value);
					});
				}

			} else if (currObType === TYPE_RECT_AREA) {

				var area = new Area({
					obType : currObType,
					obField : currObField,
					rate : currObRate,
					floorId : global.currentFloor.floorId
				});
				if (isShift) {
					setValue(area, canvasmousedown, loc);
					area.stroke(maincontext, global);
					area.fill(maincontext);
				} else {
					var pointHash = AutoAdjustment(loc);
					setValue(area, canvasmousedown, loc);
					area.stroke(maincontext, global);
					area.fill(maincontext, global);
					$.each(pointHash.options, function(index, value) {
						drawGuideLine(value);
					});
				}

			}

			global.canvasaction = "dragging";
		}

	};

	maincontext.canvas.onmouseup = function(e) {

		e.preventDefault();
		if (!loc)
			return;
		if (!loc.x)
			return;

		if (global.canvasaction == "addap") {

			var ap = {
				apId : (new UUID()).toString(),
				px : canvasmousedown.x,
				py : canvasmousedown.y,
				floorId : global.currentFloor.floorId,
				apModel : global.addApModel
			};

			if (!checkAPExclusion(ap))
				return;

			FloorInsertAp(ap, function(data) {

				ap = new AP(data);
				obstructions.push(ap.apId, ap);
				changeMenuStatus();
				setCurrObj(ap);
				resetHeatcontext();
				resetMaincontext();

			});

			return;
		}

		if (global.canvasaction == "dragging") {

			if (currObType === TYPE_DRAW_Rule) {

				var distance = Math.sqrt(Math.pow(loc.x - canvasmousedown.x, 2)
						+ Math.pow(loc.y - canvasmousedown.y, 2));

				if (distance < MINISTEP)
					ruleline = {};
				else {
					ruleline = {
						x1 : canvasmousedown.x,
						y1 : canvasmousedown.y,
						x2 : loc.x,
						y2 : loc.y
					};
					var bmap = mapImages.get(global.currentFloor.floorId);
					if (bmap != null) {
						showScalePanel(distance, bmap);
					}
				}

			}
			if (currObType === TYPE_DRAW_Ruler) {

				var distance = Math.sqrt(Math.pow(loc.x - canvasmousedown.x, 2)
						+ Math.pow(loc.y - canvasmousedown.y, 2));

				if (distance < MINISTEP)
					rulerline = {};
				else {
					rulerline = {
						x1 : canvasmousedown.x,
						y1 : canvasmousedown.y,
						x2 : loc.x,
						y2 : loc.y,
						d : (distance * global.rulescale).toFixed(2)
					};
				}
				currObType = "";
				onMovingState();
				$("#menuRuler").removeClass("active");

			} else if (currObType === TYPE_RECT_WALL) {
				var pw = loc.x;
				var ph = loc.y;
				if (isShift) {
					var w = pw - canvasmousedown.x;
					var h = ph - canvasmousedown.y;
					var length = Math.sqrt(Math.pow(Math.abs(w), 2)
							+ Math.pow(Math.abs(h), 2));

					var flagh = h > 0 ? 1 : -1;
					var flagw = w > 0 ? 1 : -1;
					var angle = Math.atan(Math.abs(h / w));
					if (angle < Math.PI / 8) {
						ph = canvasmousedown.y;
						pw = canvasmousedown.x + length * flagw;
					} else if (angle < Math.PI * 3 / 8) {
						var dis = Math.sqrt(Math.pow(length, 2) / 2);
						ph = canvasmousedown.y + dis * flagh;
						pw = canvasmousedown.x + dis * flagw;
					} else {
						pw = canvasmousedown.x;
						ph = canvasmousedown.y + length * flagh;
					}
				}
				var obstacle = new Obstacle({
					obId : (new UUID()).toString(),
					px : canvasmousedown.x,
					py : canvasmousedown.y,
					pw : pw,
					ph : ph,
					obType : currObType,
					obField : currObField,
					rate : currObRate,
					floorId : global.currentFloor.floorId
				});

				if (isShift) {
					obstacle.stroke(maincontext, global);
				} else {

					AutoAdjustment(loc);
					obstacle.pw = loc.x;
					obstacle.ph = loc.y;
					wallAutoAdjustment(obstacle);

				}

				FloorInsertOb(obstacle, function() {
					var undo = {};
					undo.obj = obstacle.obId;
					undo.oper = "add";
					undo.obType = TYPE_RECT_WALL;
					undo.canvasScale = contextClone.canvasScale;
					undo.translateOffX = contextClone.translateOffX;
					undo.translateOffY = contextClone.translateOffY;
					undolist.push(undo);
					undoChg();
				});
				obstructions.push(obstacle.obId, obstacle);

			} else if (currObType === TYPE_RECT_ZONE) {

				var zone = new Zone({
					obId : (new UUID()).toString(),
					obType : currObType,
					obField : currObField,
					floorId : global.currentFloor.floorId
				});

				AutoAdjustment(loc);
				setValue(zone, canvasmousedown, loc);

				if (zone.pw <= 0 || zone.ph <= 0) {

				} else if (!checkExclusionAP(zone)) {
					alert("Exclusion zone or elevator can not contains APs or Antennas!");

				} else if (checkRectangle(zone)) {

					FloorInsertOb(zone, function() {

						var undo = {};
						undo.obj = zone.obId;
						undo.oper = "add";
						undo.obType = TYPE_RECT_ZONE;
						undo.canvasScale = contextClone.canvasScale;
						undo.translateOffX = contextClone.translateOffX;
						undo.translateOffY = contextClone.translateOffY;
						undolist.push(undo);
						undoChg();

					});
					obstructions.push(zone.obId, zone);
					changeMenuStatus();

				} else {
					alert("Zones can not be overlapped!");
				}

			} else if (currObType === TYPE_RECT_AREA) {

				var area = new Area({
					obId : (new UUID()).toString(),
					obType : currObType,
					obField : currObField,
					rate : currObRate,
					floorId : global.currentFloor.floorId
				});
				AutoAdjustment(loc);
				setValue(area, canvasmousedown, loc);

				if (area.pw <= 0 || area.ph <= 0) {

				} else if (!checkExclusionAP(area)) {
					alert("Exclusion zone or elevator can not contains APs or Antennas!");

				} else if (checkRectangle(area)) {

					FloorInsertOb(area, function() {

						var undo = {};
						undo.obj = area.obId;
						undo.oper = "add";
						undo.obType = TYPE_RECT_AREA;
						undo.canvasScale = contextClone.canvasScale;
						undo.translateOffX = contextClone.translateOffX;
						undo.translateOffY = contextClone.translateOffY;
						undolist.push(undo);
						undoChg();
					});
					obstructions.push(area.obId, area);

				} else {
					alert("Areas can not be overlapped!");
				}
			}
		}

		global.canvasaction = "none";
		resetHeatcontext();
		resetMaincontext();

	};

};

function onMovingState() {

	maincontext.canvas.style.cursor = CURSOR_HAND;
	global.canvasaction = "none";
	hideToolPanelMenu();
	if(!global.currentAP){
		hideAPSettingPanel();
	}
	var loc;

	maincontext.canvas.onmousedown = function(e) {

		// 禁止浏览器对该事件做出默认的反应
		e.preventDefault();
		document.getElementById("maincanvas").oncontextmenu = null;
		aprightmenu.style.display = "none";
		hideToolPanelMenu();
		maincontext.canvas.ondblclick = null;
		hideAPSettingPanel();

		var point = getPointerPosition(e);
		var x = point.x, y = point.y;

		// 记录鼠标按下的位置
		loc = windowToCanvas(x, y);

		canvasmousedown.x = loc.x;
		canvasmousedown.y = loc.y;

		if (currObj) {

			var mouseloc = windowToMouse(x, y);

			if (currObj.obType === TYPE_RECT_ZONE
					|| currObj.obType === TYPE_RECT_AREA) {
				var result = currObj.inResizePath(maincontext, mouseloc);
				if (result != null) {
					if (result == "lefttop") {
						canvasmousedown.x = currObj.px + currObj.pw;
						canvasmousedown.y = currObj.py + currObj.ph;

					} else if (result == "righttop") {
						canvasmousedown.x = currObj.px;
						canvasmousedown.y = currObj.py + currObj.ph;

					} else if (result == "rightbottom") {
						canvasmousedown.x = currObj.px;
						canvasmousedown.y = currObj.py;

					} else if (result == "leftbottom") {
						canvasmousedown.x = currObj.px + currObj.pw;
						canvasmousedown.y = currObj.py;

					}
					global.canvasaction = "startresize";
					contextClone.canvasScale = global.canvasScale;
					contextClone.translateOffX = global.translateOffX;
					contextClone.translateOffY = global.translateOffY;

					return;
				}

			} else if (currObj.obType === TYPE_RECT_WALL) {
				var result = currObj.inResizePath(maincontext, mouseloc);
				if (result != null) {

					if (result == "left") {
						canvasmousedown.x = currObj.pw;
						canvasmousedown.y = currObj.ph;
					} else if (result == "right") {
						canvasmousedown.x = currObj.px;
						canvasmousedown.y = currObj.py;
					}

					contextClone.canvasScale = global.canvasScale;
					contextClone.translateOffX = global.translateOffX;
					contextClone.translateOffY = global.translateOffY;

					global.canvasaction = "startresize";

					return;
				}

			} else if (global.showWDS && currObj.apId && !currObj.atId
					&& supportWDS(currObj) == true) {

				maincontext.save();
				maincontext.setTransform(1, 0, 0, 1, 0, 0);

				if (currObj.inWDSPath(maincontext, mouseloc)) {

					global.canvasaction = "startwds";
					maincontext.canvas.style.cursor = "crosshair";

					wdsLine.apId1 = currObj.Id;
					wdsLine.x1 = currObj.px;
					wdsLine.y1 = currObj.py;
					maincontext.restore();
					return;
				} else if (currObj.antennaType && currObj.antennaType != 0) {

					if (currObj.inRotatePath(maincontext, mouseloc)) {

						global.canvasaction = "startrotate";
						maincontext.canvas.style.cursor = CURSOR_ROTATE;

						currObj.lastangle = currObj.angle;
						currObj.startangle = Math.atan((loc.y - currObj.py)
								/ (loc.x - currObj.px));
						if (((loc.y - currObj.py) > 0 && (loc.x - currObj.px) < 0)
								|| ((loc.y - currObj.py) < 0 && (loc.x - currObj.px) < 0)) {
							currObj.startangle += Math.PI;
						}
						maincontext.restore();
						return;
					}

				}
				maincontext.restore();
			} else if (currObj.antennaType && currObj.antennaType != 0) {

				maincontext.save();
				maincontext.setTransform(1, 0, 0, 1, 0, 0);

				if (currObj.inRotatePath(maincontext, mouseloc)) {

					global.canvasaction = "startrotate";
					maincontext.canvas.style.cursor = CURSOR_ROTATE;

					currObj.lastangle = currObj.angle;
					currObj.startangle = Math.atan((loc.y - currObj.py)
							/ (loc.x - currObj.px));
					if (((loc.y - currObj.py) > 0 && (loc.x - currObj.px) < 0)
							|| ((loc.y - currObj.py) < 0 && (loc.x - currObj.px) < 0)) {
						currObj.startangle += Math.PI;
					}
					maincontext.restore();
					return;
				}
				maincontext.restore();
			}

		}

		var newSel = null;
		var mouseloc = windowToMouse(x, y);
		// 遍历容器中的对象，是否被选中

		maincontext.setTransform(1, 0, 0, 1, 0, 0);

		$.each(obstructions.options, function(index, value) {
			if (value == null)
				return;

			if (value.apId) {
				if (!global.objshow.ap)
					return;

				value.createPath(maincontext, global);
				if (maincontext.isPointInPath(mouseloc.x, mouseloc.y)) {

					newSel = value;
				}
			}
		});

		maincontext.setTransform(global.canvasScale, 0, 0, global.canvasScale,
				global.translateOffX, global.translateOffY);

		$.each(obstructions.options, checkSelItem);

		function checkSelItem(index, value) {
			if (value == null)
				return;

			if (value.wdsId) {

				if ((value.band == "2.4" && global.currentBand != "24")
						|| (value.band == "5.0" && global.currentBand != "5")
						|| (value.band == "6.0" && global.currentBand != "6"))
					return;

				if (!global.showWDS)
					return;

				var ap1 = obstructions.get(value.apId1);
				var ap2 = obstructions.get(value.apId2);

				if (!ap1 || !ap2)
					return;

				if (!supportWDS(ap1) || !supportWDS(ap2))
					return;

			}

			if (!value.apId) {

				if ((value.obType == "zone" && !global.objshow.zone)
						|| (value.obType == "area" && !global.objshow.area)
						|| (value.obType == "obstacle" && !global.objshow.obstacle))
					return;

				value.createPath(maincontext);
				if (maincontext.isPointInPath(mouseloc.x, mouseloc.y)) {

					newSel = value;
				}
			}
		}

		// 没有选中某个对象，则选中整个图形
		if (newSel == null) {

			global.canvasaction = "selectall";
			maincontext.canvas.style.cursor = CURSOR_CATCH;
			setCurrObj(null);
			resetHeatcontext();
			resetMaincontext();
		} else {

			if (newSel.apId && global.meshManage) {
				if (newSel.bandList !== undefined
						&& newSel.apType == global.currentMeshGroup.apType) {
					for (var j = 0; j < newSel.bandList.length; j++) {
						if (global.currentMeshGroup
								&& newSel.bandList[j].bandName == global.currentMeshGroup.bandName) {
							if (newSel.bandList[j].meshSSID == global.currentMeshGroup.meshSSID){
									//&& newSel.bandList[j].meshPSK == global.currentMeshGroup.meshPSK) {
								newSel.bandList[j].meshSSID = "";
								//newSel.bandList[j].meshPSK = "";
								break;
							} else if (!isInMesh(newSel)) {
								newSel.bandList[j].meshSSID = global.currentMeshGroup.meshSSID;
								//newSel.bandList[j].meshPSK = global.currentMeshGroup.meshPSK;
								newSel.bandList[j].channelSize = global.currentMeshGroup.channelSize;
								newSel.bandList[j].channel = global.currentMeshGroup.channel;
								break;
							}
						}
					}

				}

			} else {
				if (newSel.apId) {
					/*
					 * if (e.buttons == 2) {
					 * 
					 * document.getElementById("maincanvas").oncontextmenu =
					 * function() { maincontext.canvas.style.cursor = "default";
					 * aprightmenu.style.left = mouseloc.x + "px";
					 * aprightmenu.style.top = mouseloc.y + "px";
					 * aprightmenu.style.display = "inline"; return false; }; }
					 */
					maincontext.canvas.ondblclick = function(e) {
						e.preventDefault();
						showAPSettingPanel(newSel.apId);
					};
				}
				setCurrObj(newSel);
			}

			if (currObj != null) {
				global.canvasaction = "selectone";
				maincontext.canvas.style.cursor = "move";

				contextClone.canvasScale = global.canvasScale;
				contextClone.translateOffX = global.translateOffX;
				contextClone.translateOffY = global.translateOffY;
			}
			resetHeatcontext();
			resetMaincontext();
		}

	};

	maincontext.canvas.onmousemove = function(e) {

		e.preventDefault();
		var point = getPointerPosition(e);
		var x = point.x, y = point.y;

		loc = windowToCanvas(x, y);

		if (canvasmousedown.x == loc.x && canvasmousedown.y == loc.y)
			return;
		tipdiv.style.display = "none";
		// 是否已生成鼠标样式
		var ifcusor = false;
		if (currObj) {

			var mouseloc = windowToMouse(x, y);
			if (currObj.obType && global.canvasaction !== "startresize"
					&& global.canvasaction !== "resizing") {

				if (currObj.inResizePath(maincontext, mouseloc) != null) {
					ifcusor = true;
				}

			} else if (global.showWDS && currObj.apId && !currObj.atId
					&& supportWDS(currObj) == true
					&& global.canvasaction !== "startwds"
					&& global.canvasaction !== "wdsing") {
				maincontext.save();
				maincontext.setTransform(1, 0, 0, 1, 0, 0);
				if (currObj.inWDSPath(maincontext, mouseloc)) {
					ifcusor = true;
				} else if (currObj.apId && currObj.antennaType != 0
						&& global.canvasaction !== "startrotate"
						&& global.canvasaction !== "rotating") {
					if (currObj.inRotatePath(maincontext, mouseloc)) {
						ifcusor = true;
					}
				}
				maincontext.restore();

			} else if (currObj.apId && currObj.antennaType != 0
					&& global.canvasaction !== "startrotate"
					&& global.canvasaction !== "rotating") {
				maincontext.save();
				maincontext.setTransform(1, 0, 0, 1, 0, 0);
				if (currObj.inRotatePath(maincontext, mouseloc)) {
					ifcusor = true;
				}
				maincontext.restore();
			}
		}

		if (global.canvasaction === "startresize"
				|| global.canvasaction === "resizing") {

			if (transformCanvas(x, y))
				resetHeatcontext();

			if (currObj.obType === TYPE_RECT_WALL) {
				var pw = loc.x;
				var ph = loc.y;
				if (isShift) {
					var w = pw - canvasmousedown.x;
					var h = ph - canvasmousedown.y;
					var length = Math.sqrt(Math.pow(Math.abs(w), 2)
							+ Math.pow(Math.abs(h), 2));

					var flagh = h > 0 ? 1 : -1;
					var flagw = w > 0 ? 1 : -1;
					var angle = Math.atan(Math.abs(h / w));
					if (angle < Math.PI / 8) {
						ph = canvasmousedown.y;
						pw = canvasmousedown.x + length * flagw;
					} else if (angle < Math.PI * 3 / 8) {
						var dis = Math.sqrt(Math.pow(length, 2) / 2);
						ph = canvasmousedown.y + dis * flagh;
						pw = canvasmousedown.x + dis * flagw;
					} else {
						pw = canvasmousedown.x;
						ph = canvasmousedown.y + length * flagh;
					}
				}
				currObj.px = canvasmousedown.x;
				currObj.py = canvasmousedown.y;
				currObj.pw = pw;
				currObj.ph = ph;

				if (!isShift) {

					var pointHash = AutoAdjustment(loc);
					currObj.pw = loc.x;
					currObj.ph = loc.y;
					wallAutoAdjustment(currObj);
					resetMaincontext();
					$.each(pointHash.options, function(index, value) {
						drawGuideLine(value);
					});
				} else {
					resetMaincontext();
				}

			} else {

				var pointHash = AutoAdjustment(loc);
				setValue(currObj, canvasmousedown, loc);
				resetMaincontext();
				$.each(pointHash.options, function(index, value) {
					drawGuideLine(value);
				});
			}

			global.canvasaction = "resizing";

		} else if (global.canvasaction === "startwds"
				|| global.canvasaction === "wdsing") {

			wdsLine.apId2 = "";
			wdsLine.x2 = loc.x;
			wdsLine.y2 = loc.y;
			global.canvasaction = "wdsing";
			resetMaincontext();
			resetHeatcontext();

			var mouseloc = windowToMouse(x, y);
			$.each(obstructions.options, function(index, value) {
				if (value == null || value.apId == undefined || value.atId)
					return;
				if (value.apId && value.apId == wdsLine.apId1)
					return;

				if (supportWDS(value) == true) {
					maincontext.save();
					maincontext.setTransform(1, 0, 0, 1, 0, 0);

					if (value.inWDSPath(maincontext, mouseloc)) {

						wdsLine.apId2 = value.Id;
						wdsLine.x2 = value.px;
						wdsLine.y2 = value.py;

						resetHeatcontext();
						resetMaincontext();
						return;
					}
					maincontext.restore();
				}
			});

		} else if (global.canvasaction === "startrotate"
				|| global.canvasaction === "rotating") {

			var changeangel = Math.atan((loc.y - currObj.py)
					/ (loc.x - currObj.px))
					- currObj.startangle;

			if (((loc.y - currObj.py) > 0 && (loc.x - currObj.px) < 0)
					|| ((loc.y - currObj.py) < 0 && (loc.x - currObj.px) < 0)) {
				changeangel += Math.PI;
			}

			currObj.angle = (changeangel + currObj.lastangle) % (Math.PI * 2);

			resetMaincontext();
			global.canvasaction = "rotating";

		} else if (global.canvasaction === "selectone"
				|| global.canvasaction === "movingone") {
			if (currObj) {

				var oldObj = obstructions.get(currObj.Id);

				if (transformCanvas(x, y))
					resetHeatcontext();

				if (currObj.px != undefined)
					currObj.px = loc.x - canvasmousedown.x + oldObj.px;
				if (currObj.py != undefined)
					currObj.py = loc.y - canvasmousedown.y + oldObj.py;

				if (currObj.obType === TYPE_RECT_WALL) {

					currObj.pw = loc.x - canvasmousedown.x + oldObj.pw;
					currObj.ph = loc.y - canvasmousedown.y + oldObj.ph;

				}

				if (currObj.apId || currObj.atId) {

					$.each(obstructions.options, function(index, value) {
						if (value != null && value.wdsId) {

							if (currObj.apId == value.apId1) {
								value.x1 = currObj.px;
								value.y1 = currObj.py;
								if (currObj.attachedId) {
									var at = getatbyapId(currObj.apId);
									if (at) {
										value.x1 = at.px;
										value.y1 = at.py;
									}
								}

							} else if (currObj.apId == value.apId2) {
								value.x2 = currObj.px;
								value.y2 = currObj.py;
								if (currObj.attachedId) {
									var at = getatbyapId(currObj.apId);
									if (at) {
										value.x2 = at.px;
										value.y2 = at.py;
									}
								}

							} else
								return;
							var distance = Math.sqrt(Math.pow(value.x2
									- value.x1, 2)
									+ Math.pow(value.y2 - value.y1, 2));
							value.distance = Math.round(distance
									* global.rulescale);

						}
					});
					
					for(var i=0;i<meshLineHash.length;i++){
						var value=meshLineHash[i];
						if (currObj.apId == value.apId1) {
							value.x1 = currObj.px;
							value.y1 = currObj.py;
							if (currObj.attachedId) {
								var at = getatbyapId(currObj.apId);
								if (at) {
									value.x1 = at.px;
									value.y1 = at.py;
								}
							}
							var distance = Math.sqrt(Math.pow(value.x2
									- value.x1, 2)
									+ Math.pow(value.y2 - value.y1, 2));
							value.distance = Math.round(distance
									* global.rulescale);

						} else if (currObj.apId == value.apId2) {
							value.x2 = currObj.px;
							value.y2 = currObj.py;
							if (currObj.attachedId) {
								var at = getatbyapId(currObj.apId);
								if (at) {
									value.x2 = at.px;
									value.y2 = at.py;
								}
							}
							var distance = Math.sqrt(Math.pow(value.x2
									- value.x1, 2)
									+ Math.pow(value.y2 - value.y1, 2));
							value.distance = Math.round(distance
									* global.rulescale);

						} 
						
					}
					
					resetHeatcontext();
					resetMaincontext();
				} else {

					if (currObj.obType === TYPE_RECT_WALL) {
						var guidLines = wallAutoMove(currObj);
						resetMaincontext();
						$.each(guidLines.options, function(index, value) {
							drawGuideLine(value);
						});
					} else {

						var pointHash = zoneAutoMove(currObj);
						resetMaincontext();
						$.each(pointHash.options, function(index, value) {
							drawGuideLine(value);
						});
					}

				}
				global.canvasaction = "movingone";

			}
		} else if (global.canvasaction === "selectall"
				|| global.canvasaction === "movingall") {

			var offX = loc.x - canvasmousedown.x;
			var offY = loc.y - canvasmousedown.y;

			global.translateOffX += offX * global.canvasScale;
			global.translateOffY += offY * global.canvasScale;
			resetHeatcontext();
			resetMaincontext();
			global.translateOffX -= offX * global.canvasScale;
			global.translateOffY -= offY * global.canvasScale;
			global.canvasaction = "movingall";

		} else if (!ifcusor) {

			var newmouseoverId = "";
			var mouseloc = windowToMouse(x, y);
			// 遍历容器中的对象，是否被选中
			maincontext.setTransform(1, 0, 0, 1, 0, 0);

			$.each(obstructions.options, function(index, value) {
				if (value == null)
					return;

				if (value.apId) {
					if (!global.objshow.ap)
						return;

					value.createPath(maincontext, global);
					if (maincontext.isPointInPath(mouseloc.x, mouseloc.y)) {

						if (value.atId)
							newmouseoverId = value.atId;
						else if (value.apId)
							newmouseoverId = value.apId;

						return;
					}
				}
			});

			var a = global.canvasScale, b = 0, c = 0, d = global.canvasScale, e = global.translateOffX, f = global.translateOffY;
			maincontext.setTransform(a, b, c, d, e, f);
			$.each(obstructions.options, checkOverItem);
			function checkOverItem(index, value) {
				if (value == null)
					return;
				if (value.wdsId) {
					if (!global.showWDS)
						return;
					var ap1 = obstructions.get(value.apId1);
					var ap2 = obstructions.get(value.apId2);

					if (!ap1 || !ap2)
						return;

					if (!supportWDS(ap1) || !supportWDS(ap2))
						return;
				}

				if (!value.apId) {
					if ((value.obType == "zone" && !global.objshow.zone)
							|| (value.obType == "area" && !global.objshow.area)
							|| (value.obType == "obstacle" && !global.objshow.obstacle))
						return;

					value.createPath(maincontext, global);
					if (maincontext.isPointInPath(mouseloc.x, mouseloc.y)) {

						if (value.obId)
							newmouseoverId = value.obId;
						else if (value.wdsId) {
							newmouseoverId = value.wdsId;
						}

						return;
					}
				}
			}
			if (newmouseoverId == "") {
				maincontext.canvas.style.cursor = CURSOR_HAND;
			} else {
				maincontext.canvas.style.cursor = 'move';

				var obj = obstructions.get(newmouseoverId);
				if (!obj.apId) {
					var desc = obj.tooltip();
					if (desc != "") {

						var bbox = maincontext.canvas.getBoundingClientRect();
						tipdiv.style.left = (loc.x * global.canvasScale + global.translateOffX)
								* bbox.width
								/ maincontext.canvas.width
								+ 10
								+ "px";
						tipdiv.style.top = (loc.y * global.canvasScale + global.translateOffY)
								* bbox.height
								/ maincontext.canvas.height
								+ "px";
						tipdiv.style.display = "inline";
						tipdiv.className = "othertip";

						var obj = obstructions.get(newmouseoverId);
						tipspan.innerText = desc;
					}
				}
			}

			if (global.mouseoverId != newmouseoverId) {
				global.mouseoverId = newmouseoverId;
				resetHeatcontext();
				resetMaincontext();
			}
		}

		if (global.canvasaction === "none") {

			if (global.showheatmap && global.currentFloor) {

				var find = null;
				if (heatArray) {
					for (var i = 0; i < heatArray.length; i++) {
						item = heatArray[i];

						if (loc.x <= item.x + heatStep / 2
								&& loc.x >= item.x - heatStep / 2
								&& loc.y <= item.y + heatStep / 2
								&& loc.y >= item.y - heatStep / 2) {
							find = item;
							if (find.w > 0) {
								console.log(find.x + "||" + find.y + "||"
										+ find.w);
							}
							break;
						}
					}
				}
				if (find != null) {
					var bbox = maincontext.canvas.getBoundingClientRect();
					var width = bbox.width;
					var left = (loc.x * global.canvasScale + global.translateOffX)
							* bbox.width / maincontext.canvas.width + 10;
					if (left + 110 < width) {
						tipdiv.style.left = left + "px";
					} else {
						tipdiv.style.left = (left - 110) + "px";
					}
					tipdiv.style.top = (loc.y * global.canvasScale + global.translateOffY)
							* bbox.height / maincontext.canvas.height + "px";
					tipdiv.className = "heattip";
					tipdiv.style.display = "inline";
					tipdiv.style.zIndex = 2000;
					tipspan.innerText = find.w.toFixed(2) + " dbm";

				}
			}
		}
	};

	maincontext.canvas.onmouseup = function(e) {

		e.preventDefault();

		if (global.canvasaction === "none"
				|| global.canvasaction === "selectall") {
			maincontext.canvas.style.cursor = CURSOR_HAND;
			global.canvasaction = "none";
			rulerline = {};
			resetMaincontext();
			return;
		}

		if (global.canvasaction === "resizing") {

			if (currObj.obType === TYPE_RECT_ZONE
					|| currObj.obType === TYPE_RECT_AREA) {

				if (!checkOverlap(currObj)) {

					alert("Zones or areas can not be overlapped!");

					setCurrObj(null);
					resetHeatcontext();
					resetMaincontext();
				} else if (!checkExclusionAP(currObj)) {

					alert("Exclusion zone or elevator can not contains APs or Antennas!");

					setCurrObj(null);
					resetHeatcontext();
					resetMaincontext();
				} else {
					FloorUpdateOb(currObj);
					obstructions.push(currObj.Id, currObj);
				}
			} else {
				var pw = currObj.pw;
				var ph = currObj.ph;
				if (isShift) {
					var w = pw - currObj.px;
					var h = ph - currObj.py;
					var length = Math.sqrt(Math.pow(Math.abs(w), 2)
							+ Math.pow(Math.abs(h), 2));

					var flagh = h > 0 ? 1 : -1;
					var flagw = w > 0 ? 1 : -1;
					var angle = Math.atan(Math.abs(h / w));
					if (angle < Math.PI / 8) {
						ph = currObj.py;
						pw = currObj.px + length * flagw;
					} else if (angle < Math.PI * 3 / 8) {
						var dis = Math.sqrt(Math.pow(length, 2) / 2);
						ph = currObj.py + dis * flagh;
						pw = currObj.px + dis * flagw;
					} else {
						pw = currObj.px;
						ph = currObj.py + length * flagh;
					}
				}
				currObj.pw = pw;
				currObj.ph = ph;

				FloorUpdateOb(currObj);
				obstructions.push(currObj.Id, currObj);
			}
		} else if (global.canvasaction === "rotating") {

			if (currObj.atId) {
				FloorUpdateAt(currObj, function() {
					refreshWds();
				});
			} else {
				FloorUpdateAp(currObj, function() {
					refreshWds();
				});
			}
			obstructions.push(currObj.Id, currObj);
		} else if (global.canvasaction === "wdsing") {

			if (wdsLine.apId2 != "") {
				var lineNew = {
					apId1 : wdsLine.apId1,
					apId2 : wdsLine.apId2,
					band : global.currentBand == "24" ? "2.4" : `${global.currentBand}.0`,
					floorId : global.currentFloor.floorId
				};
				console.log(lineNew);
				doAction(
						loader.Request.FloorInsertWds,
						lineNew,
						function(data) {
							console.log(data);
							if (data.data == -1) {
								resetHeatcontext();
								resetMaincontext();
								alert("The number of wds link has reached the maximum!");
								return;
							}
							refreshFloorDetail();

						});
			}
			wdsLine = {};

		} else if (global.canvasaction === "movingone") {
			if (currObj != null) {
				if (currObj.obType === TYPE_RECT_ZONE
						|| currObj.obType === TYPE_RECT_AREA) {

					if (!checkOverlap(currObj)) {

						alert("Zones or areas can not be overlapped!");

						setCurrObj(null);
						resetHeatcontext();
						resetMaincontext();
					} else if (!checkExclusionAP(currObj)) {

						alert("Exclusion zone or elevator can not contains APs or Antennas!");

						setCurrObj(null);
						resetHeatcontext();
						resetMaincontext();
					} else {
						FloorUpdateOb(currObj);
						obstructions.push(currObj.Id, currObj);
					}
				} else if ((currObj.atId || currObj.apId)
						&& !checkAPExclusion(currObj)) {

					alert("AP or Antenna can not in exclusion zones or elevators!");

					setCurrObj(null);
					resetHeatcontext();
					resetMaincontext();
				} else {

					if (currObj.obId) {
						FloorUpdateOb(currObj);
						obstructions.push(currObj.Id, currObj);
					} else if (currObj.atId) {
						obstructions.push(currObj.Id, currObj);
						FloorUpdateAt(currObj, function() {
							refreshWds();
						});

					} else if (currObj.apId) {
						obstructions.push(currObj.Id, currObj);
						FloorUpdateAp(currObj, function() {
							refreshWds();
						});
					}

				}
			}
		} else if (global.canvasaction === "movingall") {

			var point = getPointerPosition(e);
			var x = point.x, y = point.y;

			var loc = windowToCanvas(x, y);

			var offX = loc.x - canvasmousedown.x;
			var offY = loc.y - canvasmousedown.y;

			global.translateOffX = global.translateOffX + offX
					* global.canvasScale;
			global.translateOffY = global.translateOffY + offY
					* global.canvasScale;
			zoomChg();
			maincontext.canvas.style.cursor = CURSOR_HAND;
			showHeatMapModal();
		}

		global.canvasaction = "none"; // maincontext.canvas.style.cursor
		// =CURSOR_HAND;
	};
};

function refreshWds() {

	$.each(obstructions.options, refreshWdsItem);

	function refreshWdsItem(index, value) {
		if (value != null && value.wdsId) {

			var ap1 = obstructions.get(value.apId1);
			var ap2 = obstructions.get(value.apId2);

			if (!ap1 || !ap2)
				return;

			value.x1 = ap1.px;
			value.y1 = ap1.py;
			value.x2 = ap2.px;
			value.y2 = ap2.py;

			if (ap1.attachedId) {
				var at = getatbyapId(ap1.apId);
				if (at) {
					value.x1 = at.px;
					value.y1 = at.py;
				}
			}
			if (ap2.attachedId) {
				var at = getatbyapId(ap2.apId);
				if (at) {
					value.x2 = at.px;
					value.y2 = at.py;
				}
			}

			var distance = Math.sqrt(Math.pow(value.x2 - value.x1, 2)
					+ Math.pow(value.y2 - value.y1, 2));
			value.distance = Math.round(distance * global.rulescale);
			value.performance = "?";

			var jsondata = {
				floorId : global.currentFloor.floorId,
				apId1 : value.apId1,
				apId2 : value.apId2,
				band : value.band,
			};

			doActionParam(loader.Request.getWDSWeight, jsondata,
					function(data) {
						value.performance = Math.round(data.data);
						resetHeatcontext();
						resetMaincontext();
					});

		}
	}

	for (let i = 0; i < meshLineHash.length; i++) {
		let value = meshLineHash[i];
		let ap1 = obstructions.get(value.apId1);
		let ap2 = obstructions.get(value.apId2);

		if (!ap1 || !ap2)
			continue;

		value.x1 = ap1.px;
		value.y1 = ap1.py;
		value.x2 = ap2.px;
		value.y2 = ap2.py;

		if (ap1.attachedId) {
			let at = getatbyapId(ap1.apId);
			if (at) {
				value.x1 = at.px;
				value.y1 = at.py;
			}
		}
		if (ap2.attachedId) {
			let at = getatbyapId(ap2.apId);
			if (at) {
				value.x2 = at.px;
				value.y2 = at.py;
			}
		}

		let distance = Math.sqrt(Math.pow(value.x2 - value.x1, 2)
				+ Math.pow(value.y2 - value.y1, 2));
		value.distance = Math.round(distance * global.rulescale);

		let jsondata = {
			floorId: global.currentFloor.floorId,
			apId1: value.apId1,
			apId2: value.apId2,
			band: value.band,
		};
		value.performance = "?";
		doActionParam(loader.Request.getWDSWeight, jsondata, function(data) {
			if (!data) return;
			value.performance = Math.round(data.data);
			resetHeatcontext();
			resetMaincontext();
		});
	}
}

/**
 * 重画可编辑界面元素
 * 
 * @param tag
 *            是否画被选中对象
 */
function resetMaincontext() {
	delbtn.style.display = "none";
	maincontext.setTransform(1, 0, 0, 1, 0, 0);
	maincontext.clearRect(0, 0, maincontext.canvas.width,
			maincontext.canvas.height);
	var a = global.canvasScale, b = 0, c = 0, d = global.canvasScale, e = global.translateOffX, f = global.translateOffY;
	maincontext.setTransform(a, b, c, d, e, f);

	if (currObj != null && !currObj.apId && !currObj.wdsId) {
		currObj.fill(maincontext, global);
		currObj.stroke(maincontext, global, true);
	}

	maincontext.setTransform(1, 0, 0, 1, 0, 0);

	if (ruleline.x1) {

		maincontext.save();
		maincontext.strokeStyle = COLOR_RULE;
		maincontext.lineWidth = WIDTH_RULE;

		maincontext.beginPath();
		maincontext.moveTo(ruleline.x1 * global.canvasScale
				+ global.translateOffX, ruleline.y1 * global.canvasScale
				+ global.translateOffY);
		maincontext.lineTo(ruleline.x2 * global.canvasScale
				+ global.translateOffX, ruleline.y2 * global.canvasScale
				+ global.translateOffY);
		maincontext.stroke();
		maincontext.restore();
	} else if (rulerline.x1) {

		maincontext.save();
		maincontext.strokeStyle = COLOR_RULER;
		maincontext.lineWidth = 2;

		maincontext.beginPath();
		maincontext.moveTo(rulerline.x1 * global.canvasScale
				+ global.translateOffX, rulerline.y1 * global.canvasScale
				+ global.translateOffY);
		maincontext.lineTo(rulerline.x2 * global.canvasScale
				+ global.translateOffX, rulerline.y2 * global.canvasScale
				+ global.translateOffY);
		maincontext.stroke();

		maincontext.fillStyle = COLOR_RULER_FILL;
		maincontext.font = "bold 13px Arial";
		maincontext.lineWidth = 1;
		var txt = rulerline.d + (global.ruleunit == 0 ? "meters" : "ft");
		maincontext.rect((rulerline.x2 + 8) * global.canvasScale
				+ global.translateOffX, (rulerline.y2 + 8) * global.canvasScale
				+ global.translateOffY,
				maincontext.measureText(txt).width + 16, 29);
		maincontext.stroke();
		maincontext.fill();
		maincontext.fillStyle = COLOR_RULER;

		maincontext.fillText(txt, (rulerline.x2 + 8) * global.canvasScale
				+ global.translateOffX + 8, (rulerline.y2 + 8)
				* global.canvasScale + global.translateOffY + 19);

		maincontext.restore();
	} else if (wdsLine.x1) {

		maincontext.save();
		maincontext.strokeStyle = "#2095f2";
		maincontext.lineWidth = 4;

		maincontext.beginPath();
		maincontext.moveTo(wdsLine.x1 * global.canvasScale
				+ global.translateOffX, wdsLine.y1 * global.canvasScale
				+ global.translateOffY);
		maincontext.lineTo(wdsLine.x2 * global.canvasScale
				+ global.translateOffX, wdsLine.y2 * global.canvasScale
				+ global.translateOffY);
		maincontext.stroke();
		maincontext.restore();
	}

	if (currObj != null && currObj.apId) {
		if (currObj.atId) {
			var parentAP = obstructions.get(currObj.apId);
			currObj.fill(maincontext, global, parentAP);
			currObj.stroke(maincontext, global, true);
		} else {

			var at = getatbyapId(currObj.apId);
			if (at) {
				at.fill(maincontext, global, currObj);
				at.stroke(maincontext, global, false);
			}

			currObj.fill(maincontext, global, true);
			currObj.stroke(maincontext, global, true);
		}
	}
	if (currObj != null && currObj.wdsId) {
		currObj.fill(maincontext, global, true);
		currObj.stroke(maincontext, global, true);
	}

	maincontext.setTransform(a, b, c, d, e, f);

};

/**
 * 重画地图背景网格和热点图
 */
function resetHeatcontext() {
	tipdiv.style.display = "none";
	backcontext.setTransform(1, 0, 0, 1, 0, 0);
	backcontext.clearRect(0, 0, backcontext.canvas.width,
			backcontext.canvas.height);

	var a = global.canvasScale, b = 0, c = 0, d = global.canvasScale, e = global.translateOffX, f = global.translateOffY;

	backcontext.setTransform(a, b, c, d, e, f);

	drawBmap(backcontext, backcanvas, function() {

		drawHeatmap(backcontext);

		backcontext.setTransform(1, 0, 0, 1, 0, 0);

		if (heatStatus != "Runnable") {
			backcontext.save();
			backcontext.fillStyle = "#aaa";
			backcontext.font = "13px Arial";
			backcontext.globalAlpha = 0.5;
			for (var x = 0; x < backcontext.canvas.width; x += 200) {
				for (var y = 0; y < backcontext.canvas.height; y += 200) {
					backcontext.fillText("loading...", x + 80, y + 90);
				}
			}
			backcontext.restore();
		}

		drawDegree(backcontext, global.stepPX);
		backcontext.setTransform(a, b, c, d, e, f);
		drawRectanges(backcontext);
		backcontext.setTransform(1, 0, 0, 1, 0, 0);
		drawAPs(backcontext);
		backcontext.setTransform(a, b, c, d, e, f);
	});

};

function drawBmap(context, canvas, callback) {
	if (!global.objshow.map) {
		callback();
	} else if (global.currentFloor) {
		var bmap = mapImages.get(global.currentFloor.floorId);
		if (bmap != null) {
			bmap.paint(context, callback);
		}
	}
}

function drawHeatmap(context) {
	if (global.showheatmap) {

		if (!heatArray)
			return;

		context.save();
		context.globalAlpha = 0.7;

		heatArray.forEach(function(item, i) {
			var dbm = item.w;

			if (dbm < -75)
				return;
			if (dbm > -25)
				dbm = -25;

			var index = Math.abs(parseInt(dbm) + 25);
			if (index < 0)
				index = 0;
			if (index > 49)
				index = 49;

			if (global.colorOpp) {
				context.fillStyle = COLORArrayOpp[index];
			} else {
				context.fillStyle = COLORArray[index];
			}

			context.fillRect(item.x - heatStep / 2, item.y - heatStep / 2,
					heatStep, heatStep);

		});
		context.restore();
	}

}

/**
 * 画除被选中对象以外的其它对象
 */
function drawRectanges(context) {

	$
			.each(
					obstructions.options,
					function(index, value) {
						if (value == null)
							return;

						if (!value.apId && !value.wdsId) {
							if (currObj != null && value.Id == currObj.Id)
								return;

							if ((value.obType == "zone" && !global.objshow.zone)
									|| (value.obType == "area" && !global.objshow.area)
									|| (value.obType == "obstacle" && !global.objshow.obstacle))
								return;

							value.fill(context, global);
							value.stroke(context, global);
						}

					});

};

function drawAPs(context) {
	if (global.showWDS) {
		$.each(obstructions.options, drawAPItem);
	}
	function drawAPItem(index, value) {
		if (value == null)
			return;
		if (currObj != null && value.Id == currObj.Id)
			return;
		if (value.wdsId
				&& ((value.band == "2.4" && global.currentBand == "24") 
						|| (value.band == "5.0" && global.currentBand == "5")
						|| (value.band == "6.0" && global.currentBand == "6"))) {

			var ap1 = obstructions.get(value.apId1);
			var ap2 = obstructions.get(value.apId2);

			if (!ap1 || !ap2)
				return;

			if (!supportWDS(ap1) || !supportWDS(ap2))
				return;

			if (value.performance == undefined) {
				var jsondata = {
					floorId : global.currentFloor.floorId,
					apId1 : value.apId1,
					apId2 : value.apId2,
					band : value.band,
				};
				value.performance = "?";
				doActionParam(loader.Request.getWDSWeight, jsondata, function(
						data) {
					value.performance = Math.round(data.data);
					resetHeatcontext();
					resetMaincontext();
				});
			} else {
				value.stroke(context, global);
			}

		}

	}
	
	for(var i=0;i<meshLineHash.length;i++){
		meshLineHash[i].stroke(context, global);
	}

	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;
		var rectange = value;

		if (rectange.apId) {

			if (currObj != null && rectange.Id == currObj.Id)
				return;

			if (!global.objshow.ap)
				return;

			if (rectange.atId) {
				if (currObj == null || rectange.apId !== currObj.Id) {
					var parentAP = obstructions.get(rectange.apId);
					rectange.fill(context, global, parentAP);
					rectange.stroke(context, global);
				}

			} else if (rectange.apId) {

				// rectange.fill(context);
				rectange.stroke(context, global);

			}

		}

	});

	$.each(obstructions.options, function(index, value) {
		if (value == null)
			return;
		var rectange = value;

		if (rectange.apId) {

			if (currObj != null && rectange.Id == currObj.Id)
				return;

			if (!global.objshow.ap)
				return;

			if (rectange.atId) {

			} else if (rectange.apId) {

				rectange.fill(context, global);

			}

		}

	});

};

/**
 * 画网格
 */
function drawDegree(context, stepPX) {
	if (global.rulescale != 0)
		drawRule(context, stepPX, global.stepmeterfeet, global.ruleunit);
	if (!showdegree)
		return;

	context.save();
	context.lineWidth = 0.4;
	context.strokeStyle = GRID_LINE_COLOR;
	context.globalAlpha = 0.35;
	for (var i = 20; i < context.canvas.width; i += stepPX * 3) {
		drawLine(i + 0.5, 0, i + 0.5, context.canvas.height, context);
	}

	for (var i = stepPX * 3; i < context.canvas.height; i += stepPX * 3) {
		drawLine(0, i + 0.5, context.canvas.width, i + 0.5, context);
	}
	context.lineWidth = 0.2;
	context.strokeStyle = GRID_SENCOND_LINE_COLOR;
	context.globalAlpha = 0.3;
	for (var i = 20 + stepPX; i < context.canvas.width; i += stepPX) {
		drawLine(i + 0.5, 0, i + 0.5, context.canvas.height, context);

	}

	for (var i = stepPX; i < context.canvas.height; i += stepPX) {

		drawLine(0, i + 0.5, context.canvas.width, i + 0.5, context);

	}
	context.restore();

}

/**
 * 删除当前选中对象
 */
function deleteObj() {
	if (currObj == null)
		return;

	if (!confirm("Are you sure to delete it?")) {
		return;
	}

	if (global.currentFloor.floorType == 0) {

		if (currObj.obId) {
			FloorDeleteOb(currObj.obId, currObj.obType, currObj.obField,
					function() {
					});

			obstructions.push(currObj.obId, null);

		} else if (currObj.atId) {
			FloorDeleteAt(currObj.atId, currObj.apId, function(data) {

			});
			var ap = obstructions.get(currObj.apId);
			if (ap != null) {
				ap.attachedId = "";
			}
			obstructions.push(currObj.atId, null);

		} else if (currObj.apId) {
			var at = getatbyapId(currObj.apId);
			if (at != null) {
				obstructions.push(at.atId, null);
			}
			$.each(obstructions.options, clearWds);

			function clearWds(index, value) {
				if (value != null
						&& value.wdsId
						&& (value.apId1 == currObj.apId || value.apId2 == currObj.apId))
					obstructions.push(value.wdsId, null);
			}

			obstructions.push(currObj.apId, null);
			hideAPSettingPanel();
			FloorDeleteAp(currObj.apId, function(data) {
				if (data.attached) {
					for (var i = 0; i < data.attached.length; i++) {
						var ap = new AP(data.attached[i]);
						obstructions.push(ap.apId, ap);
					}
				}
			});

		} else if (currObj.wdsId) {

			var jsondata = {
				id : currObj.wdsId,
				apId1 : currObj.apId1,
				apId2 : currObj.apId2,
				band : currObj.band
			};

			obstructions.push(currObj.wdsId, null);
			doAction(loader.Request.FloorDeleteWds, jsondata, function(data) {

				var ap1 = new AP(data.attached[0]);
				var ap2 = new AP(data.attached[1]);
				obstructions.push(ap1.apId, ap1);
				obstructions.push(ap2.apId, ap2);

			});

		}

		setCurrObj(null);
		resetMaincontext();
		changeMenuStatus();
	} else {
		if (currObj.bind && currObj.bind.apId1) {
			doAction(loader.Request.FloorDeleteWds, currObj.bind,
					function(data) {
						refreshFloorDetail();
						currObj = null;
						showWdsCreateStart();
					});
		} else if (currObj.bind && currObj.bind.apId) {
			FloorDeleteAp(currObj.bind.apId, function(data) {
				refreshFloorDetail();
				currObj = null;
			});
		}

	}

}

/**
 * 还原画布偏移量
 */
function toTanslateZero() {

	global.translateOffX = initialOffX;
	global.translateOffY = initialOffY;
	resetHeatcontext();
	resetMaincontext();
};

function canvastoUp() {

	global.translateOffY += 50;
	resetHeatcontext();
	resetMaincontext();
};

function canvastoDown() {

	global.translateOffY -= 50;
	resetHeatcontext();
	resetMaincontext();
};

function canvastoLeft() {

	global.translateOffX += 50;
	resetHeatcontext();
	resetMaincontext();
};

function canvastoRight() {

	global.translateOffX -= 50;
	resetHeatcontext();
	resetMaincontext();
};

/**
 * 放大画布
 */
function canvasBigger() {

	/*
	 * if (global.rulescale != 0 && global.canvasScale >= 50 / global.rulescale &&
	 * global.canvasScale >= 1) return;
	 */

	if (0.02 * global.canvasScale > global.rulescale)
		return;
	if (global.canvasScale >= 6)
		return;

	var n = 0.1;
	if (global.rulescale < 0.1 && global.canvasScale < 0.1) {
		n = 0.01
		global.canvasScale = eval(parseFloat(global.canvasScale) + n);
		global.canvasScale = global.canvasScale.toFixed(2);
	} else {
		global.canvasScale = eval(parseFloat(global.canvasScale) + n);
		global.canvasScale = global.canvasScale.toFixed(1);
	}

	global.translateOffX = (2 * global.canvasScale * global.translateOffX - maincontext.canvas.width
			* n)
			/ (2 * (global.canvasScale - n));
	global.translateOffY = (2 * global.canvasScale * global.translateOffY - maincontext.canvas.height
			* n)
			/ (2 * (global.canvasScale - n));

	calculateStep(global);
	resetHeatcontext();
	resetMaincontext();
	zoomChg();
	showHeatMapModal();

};

/**
 * 缩小画布
 */
function canvasSmaller() {

	if (global.canvasScale <= (global.rulescale > 1 ? 1 : global.rulescale))
		return;

	if (global.canvasScale <= 0.01)
		return;

	var n = -0.1;
	if (global.canvasScale <= 0.1) {
		n = -0.01
		global.canvasScale = eval(global.canvasScale + n);
		global.canvasScale = global.canvasScale.toFixed(2);
	} else {
		global.canvasScale = eval(global.canvasScale + n);
		global.canvasScale = global.canvasScale.toFixed(1);
	}

	global.translateOffX = (2 * global.canvasScale * global.translateOffX - maincontext.canvas.width
			* n)
			/ (2 * (global.canvasScale - n));
	global.translateOffY = (2 * global.canvasScale * global.translateOffY - maincontext.canvas.height
			* n)
			/ (2 * (global.canvasScale - n));

	calculateStep(global);
	resetHeatcontext();
	resetMaincontext();
	zoomChg();
	showHeatMapModal();

};

function resetScale(e) {

	global.canvasScale = 1;
	global.translateOffX = initialOffX;
	global.translateOffY = initialOffY;

	calculateStep(global);
	resetHeatcontext();
	resetMaincontext();
	zoomChg();
	showHeatMapModal();

};

function newAP(apModel) {

	global.addApModel = apModel;
	showEditToolbar("#2196f3", "Add AP", apModel);
	onDrawState();
	global.canvasaction = "addap";
	maincontext.canvas.style.cursor = CURSOR_ADDAP;
	resetMaincontext();
	return;

	/*
	 * var apId = (new UUID()).toString();
	 * 
	 * var left = backcanvas.width * Math.random() - backcanvas.width / 2; var
	 * top = backcanvas.height * Math.random() - backcanvas.height / 2;
	 * 
	 * var ap = { apId : apId, px : left, py : top, floorId :
	 * global.currentFloor.floorId, apModel : apModel };
	 * 
	 * var count = 1; var check = true; do { if (count % 2 == 0) ap.py += 20;
	 * else ap.px += 20; count++; check = checkAPExclusion(ap); } while
	 * (!check);
	 * 
	 * FloorInsertAp(ap, function(data) {
	 * 
	 * ap = new AP(data); obstructions.push(ap.apId, ap); changeMenuStatus();
	 * changeHand(); setCurrObj(ap); resetHeatcontext(); resetMaincontext();
	 * 
	 * });
	 */

};

/**
 * 重新加载画布数据源
 * 
 * @param data
 */
function canvasResetData() {

	var data = global.currentFloor;

	if (data.scale == 0) {
		$(".floor_topmenu").css("display", "none");
		$(".floor_topmenu_min").css("display", "none");
		$("#scalepanel").css("display", "none");
		$("#setscaleStart").css("display", "block");
		$("#resetscalebtn").hide();
	} else {
		$(".floor_topmenu").css("display", "block");
		$(".floor_topmenu_min").css("display", "none");
		$("#scalepanel").css("display", "none");
		$("#setscaleStart").css("display", "none");
		$("#resetscalebtn").show();
	}
	ruleline = {};
	rulerline = {};

	common.changeDivHeight();
	undolist = [];
	undoChg();

	setCurrObj(null);
	obstructions.clearData();
	resetHeatcontext();
	resetMaincontext();

	if (data == null)
		return;

	global.ruleunit = data.unit;
	global.rulescale = data.scale;

	canvasAutoresize();
	global.translateOffX = initialOffX;
	global.translateOffY = initialOffY;
	global.canvasScale = 1;

	calculateStep(global);

	/**
	 * Zone Area Obstacle先后顺序添加
	 */
	if (data.obList) {
		data.obList.forEach(function(obj) {

			if (obj.obType == TYPE_RECT_ZONE) {
				var ob = new Zone(obj);
				obstructions.push(ob.obId, ob);
			}

		});
		data.obList.forEach(function(obj) {

			if (obj.obType == TYPE_RECT_AREA) {
				var ob = new Area(obj);
				obstructions.push(ob.obId, ob);
			}
			if (obj.obType == TYPE_RECT_WALL) {
				var ob = new Obstacle(obj);
				obstructions.push(ob.obId, ob);
			}

		});
	}

	if (data.atList) {

		data.atList.forEach(function(obj) {

			var antenna = new Antenna(obj);
			obstructions.push(antenna.atId, antenna);

		});

	}
	if (data.apList) {
		data.apList.forEach(function(obj) {

			var ap = new AP(obj);
			obstructions.push(ap.apId, ap);
		});
	}

	if (data.wdsList) {
		data.wdsList.forEach(function(obj) {
			var wdsLine = new WDSLine(obj);
			var ap1 = obstructions.get(wdsLine.apId1);
			var ap2 = obstructions.get(wdsLine.apId2);

			if (!ap1 || !ap2)
				return;

			var jsondata = {
				floorId : global.currentFloor.floorId,
				apId1 : ap1.apId,
				apId2 : ap2.apId,
				band : wdsLine.band,
			};
			wdsLine.performance = "?";
			doActionParam(loader.Request.getWDSWeight, jsondata,
					function(data) {
						wdsLine.performance = Math.round(data.data);
						obstructions.push(wdsLine.wdsId, wdsLine);
						resetHeatcontext();
						resetMaincontext();
					});

			wdsLine.x1 = ap1.px;
			wdsLine.y1 = ap1.py;
			wdsLine.x2 = ap2.px;
			wdsLine.y2 = ap2.py;

			if (ap1.attachedId) {
				var at = getatbyapId(ap1.apId);
				if (at) {
					wdsLine.x1 = at.px;
					wdsLine.y1 = at.py;
				}
			}
			if (ap2.attachedId) {
				var at = getatbyapId(ap2.apId);
				if (at) {
					wdsLine.x2 = at.px;
					wdsLine.y2 = at.py;
				}
			}

			var distance = Math.sqrt(Math.pow(wdsLine.x2 - wdsLine.x1, 2)
					+ Math.pow(wdsLine.y2 - wdsLine.y1, 2));
			wdsLine.distance = Math.round(distance * global.rulescale);

			obstructions.push(wdsLine.wdsId, wdsLine);
		});
	}

	workarea.px = data.drawx;
	workarea.py = data.drawy;
	workarea.pw = data.draww;
	workarea.ph = data.drawh;

	var bmap = mapImages.get(global.currentFloor.floorId);
	if (bmap == null && data.path) {

		if (data.imagex == 0 && data.imagey == 0 && data.imagew == 0
				&& data.imageh == 0) {

			var image = new Image;
			// 去掉清除缓存的后缀
			image.src = data.path + "?" + Math.random();
			// image.src = data.path;
			image.onload = function(e) {

				var len = 10;

				var cheight = backcanvas.height - len * 2;
				var cwidth = backcanvas.width - len * 2;
				var rate = cheight / (this.height * 1.2);
				if (cwidth / cheight < this.width / this.height) {
					rate = cwidth / (this.width * 1.2);
					data.imagex = len - backcanvas.width / 2;
					data.imagey = (cheight - (this.height * 1.2) * rate) / 2
							- backcanvas.height / 2;
				} else {
					data.imagex = (cwidth - (this.width * 1.2) * rate) / 2
							- backcanvas.width / 2;
					data.imagey = len - backcanvas.height / 2;
				}

				data.imagew = this.width * 1.2 * rate;
				data.imageh = this.height * 1.2 * rate;

				/*
				 * var jsondata = { "floorId" : global.currentFloor.floorId,
				 * "imagex" : data.imagex, "imagey" : data.imagey, "imagew" :
				 * data.imagew, "imageh" : data.imageh, "unit" : data.unit };
				 * doAction(loader.Request.FloorUpdate, jsondata);
				 */

				bmap = new ImagePainter(data.path, data.imagex, data.imagey,
						data.imagew, data.imageh);
				mapImages.push(global.currentFloor.floorId, bmap);
				resetHeatcontext();
				resetMaincontext();
				changeMenuStatus();
				changeHand();
				zoomChg();
			};

		} else {
			bmap = new ImagePainter(data.path, data.imagex, data.imagey,
					data.imagew, data.imageh);
			mapImages.push(global.currentFloor.floorId, bmap);
			resetHeatcontext();
			resetMaincontext();
			changeMenuStatus();
			changeHand();
			zoomChg();
		}

	} else {
		resetHeatcontext();
		resetMaincontext();
		changeMenuStatus();
		changeHand();
		zoomChg();
	}

};

function undoDraw() {
	if (undolist.length < 1)
		return;
	var undo = undolist[undolist.length - 1];

	FloorDeleteOb(undo.obj, undo.obType, undo.obField);
	obstructions.push(undo.obj, null);
	setCurrObj(null);

	undolist.remove(undo);
	resetHeatcontext();
	resetMaincontext();
	undoChg();
	changeMenuStatus();
};

/**
 * 更新当前选中对象
 * 
 * @param value
 */
function setCurrObj(value) {

	if (value == null) {
		currObj = null;
		showRemoveMenu();
		return;
	}

	currObj = cloneObj(value);
	showRemoveMenu();
}

function cloneObj(value) {
	if (value.atId) {
		return new Antenna(value);
	} else if (value.apId) {
		return new AP(value);

	} else if (value.obId) {
		if (value.obType === TYPE_RECT_ZONE)
			return new Zone(value);
		else if (value.obType === TYPE_RECT_WALL)
			return new Obstacle(value);
		else if (value.obType === TYPE_RECT_AREA)
			return new Area(value);
	} else if (value.wdsId) {
		return value;
	}
	return null;
}

function supportWDS(ap) {
	if (ap.bandList !== undefined) {
		for (var j = 0; j < ap.bandList.length; j++) {

			if (global.currentBand == "24" && ap.bandList[j].bandName == "2.4") {
				return ap.bandList[j].wds == 1;
			} else if (global.currentBand == "5"
					&& ap.bandList[j].bandName == "5.0") {
				return ap.bandList[j].wds == 1;
			} else if (global.currentBand == "6"
					&& ap.bandList[j].bandName == "6.0") {
				return ap.bandList[j].wds == 1;
			}
			
		}
	}
	return false;

}

function displaywheel(e) {
	var evt = window.event || e;
	var delta = evt.detail ? evt.detail * (-120) : evt.wheelDelta;
	if (delta > 0) {
		canvasBigger();
	} else {
		canvasSmaller();
	}
	zoomChg();

}

var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll"
		: "mousewheel"; // FF doesn't recognize mousewheel as of FF3.x
maincanvas = document.getElementById("maincanvas");
if (maincanvas.attachEvent) // if IE (and Opera depending on user setting)
	maincanvas.attachEvent("on" + mousewheelevt, function(e) {
		e.preventDefault();
		displaywheel(e);
	});
else if (maincanvas.addEventListener) // WC3 browsers
	maincanvas.addEventListener(mousewheelevt, function(e) {
		e.preventDefault();
		displaywheel(e);
	}, false);